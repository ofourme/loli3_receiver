C51 COMPILER V9.59.0.0   LIB                                                               01/09/2022 02:19:05 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE LIB
OBJECT MODULE PLACED IN .\Objects\lib.obj
COMPILER INVOKED BY: C:\bin\Keil_v5\C51\BIN\C51.EXE lib.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\l
                    -ib.lst) TABS(2) OBJECT(.\Objects\lib.obj)

line level    source

   1          /*
   2          ********************************************************************************
   3          *                             ---ofme---
   4          *           Copyleft (c) 2021, å¾®é£å±±è°· / ofourme@163.com
   5          *           License: LGPL
   6          *
   7          *   LIB.C-V0.6.0 (2021.Dec.26th)
   8          *
   9          ********************************************************************************
  10          */
  11          
  12          #define __LIB_C__
  13          
  14          /*-DO NOT ADD YOUR CODE BEFORE HERE!-*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\-WIDTH: 80-*/
  15          /******************************************************************************/
  16          
  17          #include "lib.h"
  18          #include "app.h"
  19          
  20          /*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
  21          
  22          static idata u32 _sys_ms;
  23          static idata u16 _sys_us;
  24          
  25          extern Loli3RecvSet  xdata recvSet;
  26          extern Loli3RecvData recv;
  27          extern STimer idata timer[];
  28          
  29          /*////////////////////////////////////////////////////////////////////////////*/
  30          //ä¸²å£é€šä¿¡
  31          #if defined( SBUS_BPS_115200 )
  32            #define UART_BPS  UART_BPS_115200
  33          #elif defined ( SBUS_BPS_9600 )
                #define UART_BPS  UART_BPS_9600
              #else
                #define UART_BPS  UART_BPS_100K
              #endif
  38          
  39          /*////////////////////////////////////////////////////////////////////////////*/
  40          
  41          void port_init()
  42          {
  43   1        //51 IOå£é»˜è®¤å‡†åŒå‘å£æ¨¡å¼ï¼Œæ— éœ€ä¿®æ”¹PxM0å’ŒPxM1
  44   1        CH1=0;
  45   1        CH2=0;
  46   1        CH3=0;
  47   1        CH4=0;
  48   1        CH5=0;
  49   1        CH6=0;
  50   1        CH7=0;
  51   1        CH8=0;
  52   1      
  53   1        //å°†ADè¾“å…¥å£è®¾ç½®ä¸ºé«˜é˜»è¾“å…¥ï¼Œè¯¦è§STC15æ‰‹å†ŒP400è¦æ±‚
  54   1        P1M1 |=  1<<3;  //8é€šé“æ¥æ”¶æœºä½¿ç”¨P1.3å£åšADè¾“å…¥å£
C51 COMPILER V9.59.0.0   LIB                                                               01/09/2022 02:19:05 PAGE 2   

  55   1        P1M0 &=~(1<<3);
  56   1        //P1M1=  1<<1;    //6é€šé“æ¥æ”¶æœºä½¿ç”¨P1.1å£åšADè¾“å…¥å£
  57   1      }
  58          
  59          void port_ch5_mode_OUTPUT()
  60          {
  61   1          P3M0=1<<3;;   //CH5ï¼ˆ8é€šé“ä¸ºP3.3ï¼‰è®¾ä¸ºæ¨æŒ½
  62   1          //P3M0=1<<1;  //CH5ï¼ˆ6é€šé“ä¸ºP3.1ï¼‰è®¾ä¸ºæ¨æŒ½
  63   1      }
  64          void port_ch5_clr()
  65          {
  66   1        CH5 = 0;
  67   1      }
  68          void port_ch5_set()
  69          {
  70   1        CH5 = 1;
  71   1      }
  72          
  73          void port_ch6_mode_INPUT_PULLUP()
  74          {
  75   1        CH6=1;  // é»˜è®¤å‡†åŒå‘å£æ¨¡å¼ï¼Œè®¾ç½®1ä¸Šæ‹‰ï¼Ÿ
  76   1      }
  77          
  78          u8   port_ch6_get()
  79          {
  80   1        return (u8)(CH6);
  81   1      }
  82          
  83          void port_chs_mode_OUTPUT()
  84          {
  85   1        CH1=0;
  86   1        CH2=0;
  87   1        CH3=0;
  88   1        CH4=0;
  89   1        CH5=0;
  90   1        CH6=0;
  91   1      //stc51 uart å£è¾“å‡º0å°†å¯¼è‡´ä¸²å£æ— æ³•è¾“å‡º//CH7=0;//PIN_SBUS=1;
  92   1        CH8=0;
  93   1        P3M0=0xff;  //å°†é€šé“è¾“å‡ºIOå£P3é…ç½®ä¸ºæ¨æŒ½æ¨¡å¼ï¼Œä¿è¯æ­£å¸¸é©±åŠ¨ç”µè°ƒä¸èˆµæœº
  94   1      }
  95          
  96          /*////////////////////////////////////////////////////////////////////////////*/
  97          
  98          void pwm_en(u8 ch)
  99          {
 100   1        if(ch==1)     CCAPM2=0x42;  //PCAæ¯”è¾ƒ/æ•è·å¯„å­˜å™¨ï¼šå…è®¸æ¯”è¾ƒå™¨åŠŸèƒ½ï¼Œå…è®¸è„‰å®½è°ƒèŠ‚è¾“å‡º
 101   1        else if(ch==2)CCAPM1=0x42;
 102   1      }
 103          
 104          void pwm_dis(u8 ch)
 105          {
 106   1        if(ch==1)     CCAPM2 = 0;   //PCAæ¯”è¾ƒ/æ•è·å¯„å­˜å™¨ï¼šç¦æ­¢æ¯”è¾ƒå™¨åŠŸèƒ½ï¼Œç¦æ­¢è„‰å®½è°ƒèŠ‚è¾“å‡º
 107   1        else if(ch==2)CCAPM1 = 0;
 108   1      }
 109          
 110          void pwm_set(u8 ch, u8 pwm)
 111          {
 112   1        if(ch==1)
 113   1        {
 114   2          if(pwm>10) PCA_PWM2=0x00; // CCAPxH/CCAPxLç¬¬9ä½æ•°ä¸º0
 115   2          else    PCA_PWM2=0x03;  // CCAPxH/CCAPxLç¬¬9ä½æ•°ä¸º1
 116   2          CCAP2H=255-pwm;         // CLæº¢å‡ºæ—¶CCAPxH[0~8]æ•°æ®è½½å…¥CCAPxL[0~8]
C51 COMPILER V9.59.0.0   LIB                                                               01/09/2022 02:19:05 PAGE 3   

 117   2        }
 118   1        else if(ch==2)
 119   1        {
 120   2          if(pwm>20) PCA_PWM1=0x00;
 121   2          else    PCA_PWM1=0x03;
 122   2          CCAP1H=255-pwm;
 123   2        }
 124   1      }
 125          
 126          /*////////////////////////////////////////////////////////////////////////////*/
 127          
 128          void hw_init()
 129          {
 130   1        //ç¦æ­¢æ‰€æœ‰ä¸­æ–­
 131   1        IE = 0;
 132   1        IE2= 0;
 133   1      
 134   1        //ç”µå‹æµ‹é‡åŠŸèƒ½åˆå§‹åŒ–
 135   1        ADC_CONTR=0x80;   //ADCä¸Šç”µ
 136   1        delay(2);     //å»¶æ—¶ç­‰å¾…ADCæ¨¡å—ç¨³å®š
 137   1      
 138   1        P1ASF=0x00;             //ä¸è¯»å–P1å£ï¼Œè€Œæ˜¯ä¸‹æ¬¡è¯»å–å†…éƒ¨å‚è€ƒç”µå‹ä¿å­˜åœ¨_adc_icé‡Œ
 139   1        ADC_CONTR=0x88;         //å¯åŠ¨è½¬æ¢
 140   1        while(ADC_CONTR&0x10==0);//ç­‰å¾…è½¬æ¢å®Œæˆ
 141   1      
 142   1        //èˆµé‡è¾“å‡ºæ§åˆ¶å®šæ—¶å™¨ä¸­æ–­åˆå§‹åŒ–ï¼Œé«˜ä¼˜å…ˆçº§
 143   1        IP=0x02;      //T0ä¸­æ–­é«˜ä¼˜å…ˆçº§ï¼Œå…¶å®ƒä½ä¼˜å…ˆçº§
 144   1        TMOD &= 0x0F; //T0è®¾ç½®ä¸ºæ¨¡å¼0ï¼š16ä½è‡ªåŠ¨é‡è£…å®šæ—¶å™¨ï¼Œå½“æº¢å‡ºæ—¶å°†RL_TH0å’ŒRL_TL0å­˜æ”¾çš„
             -å€¼è‡ªåŠ¨é‡è£…å…¥TH0å’ŒTL0ä¸­
 145   1        TMOD |= 0x00;
 146   1        IE=0x02; //å…è®¸T0ä¸­æ–­
 147   1      
 148   1        //ç¡¬ä»¶PWMè¾“å‡ºåŠŸèƒ½åˆå§‹åŒ–
 149   1        P_SW1 &= ~(3<<4); //å¤–è®¾åŠŸèƒ½åˆ‡æ¢å¯„å­˜å™¨1ï¼šPWMå¼•è„šåˆ‡æ¢åˆ°P3.5~P3.7
 150   1        P_SW1 |= 1<<4;
 151   1        PCA_PWM2=0x03;    //CH1ï¼ˆP3.7ï¼‰8ä½PWMæ¨¡å¼
 152   1        PCA_PWM1=0x03;    //CH2ï¼ˆP3.6ï¼‰8ä½PWMæ¨¡å¼
 153   1        //PCA_PWM0=0x03;  //CH3ï¼ˆP3.5ï¼‰8ä½PWMæ¨¡å¼
 154   1        pwm_dis(1);
 155   1        pwm_dis(2);
 156   1      
 157   1        //ä»»åŠ¡å®šæ—¶å™¨ä¸­æ–­åˆå§‹åŒ–
 158   1        _sys_ms = 0;
 159   1        CCON =0x00;     //PCAæ§åˆ¶å¯„å­˜å™¨ï¼šåœæ­¢PCAå®šæ—¶å™¨ï¼Œæ¸…é™¤ä¸­æ–­æ ‡å¿—
 160   1        CL=0;CH=0;      //å¤ä½PCAè®¡æ•°å™¨
 161   1        CMOD=0x00;      //PCAå·¥ä½œæ¨¡å¼å¯„å­˜å™¨ï¼šç©ºé—²æ¨¡å¼ä¸‹ç»§ç»­å·¥ä½œï¼Œç³»ç»Ÿæ—¶é’Ÿ/12ï¼Œè®¡æ•°æº¢å‡ºä¸­
             -æ–­ç¦æ­¢
 162   1        _sys_us = 1000; //1 ms
 163   1        CCAP0L = _sys_us;
 164   1        CCAP0H = _sys_us >> 8;
 165   1        CCAPM0 = 0x49;  //PCAæ¨¡å—0çš„æ¯”è¾ƒ/æ•è·å¯„å­˜å™¨ï¼šå…è®¸æ¯”è¾ƒå™¨åŠŸèƒ½ï¼ŒåŒ¹é…ç½®ä½CCONæ ‡å¿—ä½C
             -CF0ï¼Œä½¿èƒ½CCF0ä¸­æ–­
 166   1      
 167   1        //SBUSåŠŸèƒ½åˆå§‹åŒ–
 168   1        UART_init(UART_BPS);
 169   1      }
 170          
 171          /*////////////////////////////////////////////////////////////////////////////*/
 172          
 173          u16 adc_read()
 174          {
 175   1        u16 adc;
C51 COMPILER V9.59.0.0   LIB                                                               01/09/2022 02:19:05 PAGE 4   

 176   1        
 177   1        adc=ADC_RES;
 178   1        adc<<=2,adc+=ADC_RESL;
 179   1      
 180   1        return adc;
 181   1      }
 182          
 183          void adc_open(u8 i) //0ï¼šå†…éƒ¨å‚è€ƒç”µå‹ï¼›1ï¼šå¤–éƒ¨ç”µå‹
 184          {
 185   1        if(i&0x01)
 186   1        {
 187   2          P1ASF=0x01<<3;    //P1å£æ¨¡æ‹ŸåŠŸèƒ½æ§åˆ¶å¯„å­˜å™¨ï¼šp1.3ä½œä¸ºæ¨¡æ‹ŸåŠŸèƒ½A/Dä½¿ç”¨ï¼Œä¸‹æ¬¡è¯»å–ç”µæ±
             - ç”µå‹ä¿å­˜åœ¨_adc_batté‡Œ
 188   2          ADC_CONTR= 1<<7 | 0<<4 | 1<<3 | 3<<0;   //ADCæ§åˆ¶å¯„å­˜å™¨ï¼šæ‰“å¼€ADè½¬æ¢å™¨ç”µæº/æ¸…é™¤è½¬æ¢ç»“æŸ
             -æ ‡å¿—ä½/å¯åŠ¨ADè½¬æ¢/p1.3ä½œADè¾“å…¥
 189   2        }
 190   1        else
 191   1        {
 192   2          P1ASF=0x00;       //ä¸è¯»å–P1å£ï¼Œè€Œæ˜¯ä¸‹æ¬¡è¯»å–å†…éƒ¨å‚è€ƒç”µå‹ä¿å­˜åœ¨_adc_icé‡Œ
 193   2          ADC_CONTR=0x88;   //å¯åŠ¨è½¬æ¢
 194   2        }
 195   1      }
 196          
 197          
 198          /*////////////////////////////////////////////////////////////////////////////*/
 199          // CHx output
 200          void ET0_isr()interrupt 1 using 1 //å®šæ—¶å™¨0ç”¨ä½œä¿¡å·è¾“å‡º
 201          {
 202   1        static u16 temp=0;
 203   1        static u16 temp1=0;
 204   1        static u16 temp2=0;
 205   1        static u8 state = 0;
 206   1        static u8 T_h=0,T_l=0;
 207   1      
 208   1      /*  
 209   1        if(recv.bModeChange)
 210   1        {
 211   1          recv.bModeChange = 0;
 212   1          state = 0;
 213   1        }
 214   1      */  
 215   1        if(recvSet.PPM)       //è¾“å‡º8é€šé“PPMï¼ŒPPMä¿¡å·æ€»å‘¨æœŸ20msï¼Œ
 216   1        {
 217   2                    //æ¯é€šé“å›ºå®š0.4msä½ç”µå¹³å¼€å§‹ï¼Œ0.6åˆ°1.6msé«˜ç”µå¹³ç»“æŸ
 218   2          state++;
 219   2          switch(state)
 220   2          {
 221   3            case 1:CH1=1;TL0=0x70,TH0=0xfe;temp=64935-recv.CH_data[0];
 222   3                    T_l=temp;T_h=temp>>8;break;
 223   3            case 2:CH1=0;TL0=T_l;TH0=T_h;break;
 224   3            case 3:CH1=1;TL0=0x70,TH0=0xfe;temp=64935-recv.CH_data[1];
 225   3                    T_l=temp;T_h=temp>>8;break;
 226   3            case 4:CH1=0;TL0=T_l;TH0=T_h;break;
 227   3            case 5:CH1=1;TL0=0x70,TH0=0xfe;temp=64935-recv.CH_data[2];
 228   3                    T_l=temp;T_h=temp>>8;break;
 229   3            case 6:CH1=0;TL0=T_l;TH0=T_h;break;
 230   3            case 7:CH1=1;TL0=0x70,TH0=0xfe;temp=64935-recv.CH_data[3];
 231   3                    T_l=temp;T_h=temp>>8;break;
 232   3            case 8:CH1=0;TL0=T_l;TH0=T_h;break;
 233   3            case 9:CH1=1;TL0=0x70,TH0=0xfe;temp=64935-recv.CH_data[4];
 234   3                    T_l=temp;T_h=temp>>8;break;
 235   3            case 10:CH1=0;TL0=T_l;TH0=T_h;break;
C51 COMPILER V9.59.0.0   LIB                                                               01/09/2022 02:19:05 PAGE 5   

 236   3            case 11:CH1=1;TL0=0x70,TH0=0xfe;temp=64935-recv.CH_data[5];
 237   3                    T_l=temp;T_h=temp>>8;break;
 238   3            case 12:CH1=0;TL0=T_l;TH0=T_h;break;
 239   3            case 13:CH1=1;TL0=0x70,TH0=0xfe;temp=64935-recv.CH_data[6];
 240   3                    T_l=temp;T_h=temp>>8;break;
 241   3            case 14:CH1=0;TL0=T_l;TH0=T_h;break;
 242   3            case 15:CH1=1;TL0=0x70,TH0=0xfe;temp=64935-recv.CH_data[7];
 243   3                    T_l=temp;T_h=temp>>8;break;
 244   3            case 16:CH1=0;TL0=T_l;TH0=T_h;break;
 245   3            case 17:CH1=1;TL0=0x70,TH0=0xfe;break;
 246   3            default:CH1=0;TL0=0xf0,TH0=0xd8;state=0;break;
 247   3          }
 248   2        }
 249   1        else if(recvSet.SBUS)
 250   1        {
 251   2          PIN_SBUS=1;
 252   2          if(state>24)
 253   2          {
 254   3            state=0;
 255   3          }
 256   2          else
 257   2          {
 258   3            UART_pushByte(recv.SBUS_tx[state]);
 259   3            state++;
 260   3          }
 261   2          if(state==25)
 262   2          {
 263   3            TL0=0xF0;TH0=0xD8;//10ms
 264   3          }
 265   2          else
 266   2          {
 267   3            TL0=0x88;TH0=0xFF;//120us
 268   3          }
 269   2        }
 270   1        else
 271   1        {
 272   2          state++;
 273   2          switch(state)
 274   2          {
 275   3            case 1:
 276   3                if(recvSet.CH1_PWM)//è¾“å‡ºPWM
 277   3                {
 278   4                  pwm_set(1,recv.CH_data[0]/4);
 279   4                }
 280   3                else if(recvSet.CH1_SW)//è¾“å‡ºç”µå¹³ä¿¡å·
 281   3                {
 282   4                  if(recv.CH_data[0]<500) CH1=0;
 283   4                  else  CH1=1;
 284   4                }
 285   3                else
 286   3                {
 287   4                  CH1=1;  //è¾“å‡ºèˆµé‡
 288   4                }
 289   3                temp2=128600-temp1;
 290   3                TL0=temp2,TH0=temp2>>8;
 291   3                break;
 292   3       
 293   3            case 2:
 294   3                if(recvSet.CH1_PWM==0 && recvSet.CH1_SW==0) //è¾“å‡ºèˆµé‡
 295   3                {
 296   4                  CH1=0;
 297   4                }
C51 COMPILER V9.59.0.0   LIB                                                               01/09/2022 02:19:05 PAGE 6   

 298   3                temp1=64725-recv.CH_data[1]*27/20;
 299   3                TL0=temp1,TH0=temp1>>8;
 300   3                break;
 301   3      
 302   3            case 3:
 303   3                if(recvSet.CH2_PWM)
 304   3                {
 305   4                  pwm_set(2,recv.CH_data[1]/4);
 306   4                }
 307   3                else if(recvSet.CH2_SW)
 308   3                {
 309   4                    if(recv.CH_data[1]<500)CH2=0;
 310   4                    else CH2=1;
 311   4                }
 312   3                else CH2=1;
 313   3                temp2=128600-temp1;
 314   3                TL0=temp2,TH0=temp2>>8;
 315   3                break;
 316   3                
 317   3            case 4:
 318   3                if(recvSet.CH2_PWM==0 && recvSet.CH2_SW==0)
 319   3                {
 320   4                    CH2=0;
 321   4                }
 322   3                temp1=64725-recv.CH_data[2]*27/20;
 323   3                TL0=temp1,TH0=temp1>>8;
 324   3                break;
 325   3              
 326   3            case 5:
 327   3                if(recvSet.CH3_SW)
 328   3                {
 329   4                  if(recv.CH_data[2]<500)CH3=0;
 330   4                  else CH3=1;
 331   4                }
 332   3                else CH3=1;
 333   3                temp2=128600-temp1;
 334   3                TL0=temp2,TH0=temp2>>8;
 335   3                break;
 336   3              
 337   3            case 6:
 338   3                if(recvSet.CH3_SW==0)CH3=0;
 339   3                temp1=64725-recv.CH_data[3]*27/20;
 340   3                TL0=temp1,TH0=temp1>>8;
 341   3                break;
 342   3            
 343   3            case 7:
 344   3              if(recvSet.CH4_SW)
 345   3                    {
 346   4                      if(recv.CH_data[3]<500)CH4=0;
 347   4                      else CH4=1;
 348   4                    }
 349   3                    else CH4=1;
 350   3                    temp2=128600-temp1;
 351   3                    TL0=temp2,TH0=temp2>>8;break;
 352   3            case 8:if(recvSet.CH4_SW==0)CH4=0;
 353   3                    temp1=64725-recv.CH_data[4]*27/20;
 354   3                    TL0=temp1,TH0=temp1>>8;break;
 355   3            case 9:if(recvSet.CH5_SW)
 356   3                    {
 357   4                      if(recv.CH_data[4]<500)CH5=0;
 358   4                      else CH5=1;
 359   4                    }
C51 COMPILER V9.59.0.0   LIB                                                               01/09/2022 02:19:05 PAGE 7   

 360   3                    else CH5=1;
 361   3                      temp2=128600-temp1;
 362   3                    TL0=temp2,TH0=temp2>>8;break;
 363   3            case 10:if(recvSet.CH5_SW==0)CH5=0;
 364   3                    temp1=64725-recv.CH_data[5]*27/20;
 365   3                    TL0=temp1,TH0=temp1>>8;break;
 366   3            case 11:if(recvSet.CH6_SW)
 367   3                    {
 368   4                      if(recv.CH_data[5]<500)CH6=0;
 369   4                      else CH6=1;
 370   4                    }
 371   3                    else CH6=1;
 372   3                      temp2=128600-temp1;
 373   3                    TL0=temp2,TH0=temp2>>8;break;
 374   3            case 12:if(recvSet.CH6_SW==0)CH6=0;
 375   3                    temp1=64725-recv.CH_data[6]*27/20;
 376   3                    TL0=temp1,TH0=temp1>>8;break;
 377   3            case 13:
 378   3                    #ifndef SBUS_DEBUG
                            if(recvSet.CH7_SW)
                            {
                              if(recv.CH_data[6]<500)CH7=0;
                              else CH7=1;
                            }
                            else CH7=1;
                            #endif
 386   3                    temp2=128600-temp1;
 387   3                    TL0=temp2,TH0=temp2>>8;break;
 388   3            case 14:
 389   3                    #ifndef SBUS_DEBUG
                            if(recvSet.CH7_SW==0)CH7=0;
                            #endif
 392   3                    temp1=64725-recv.CH_data[7]*27/20;
 393   3                    TL0=temp1,TH0=temp1>>8;break;
 394   3            case 15:if(recvSet.CH8_SW)
 395   3                    {
 396   4                      if(recv.CH_data[7]<500)CH8=0;
 397   4                      else CH8=1;
 398   4                    }
 399   3                    else CH8=1;
 400   3                    temp2=128600-temp1;
 401   3                    TL0=temp2,TH0=temp2>>8;break;
 402   3            default:if(recvSet.CH8_SW==0)CH8=0;
 403   3                    temp1=64725-recv.CH_data[0]*27/20;
 404   3                    TL0=temp1,TH0=temp1>>8;state=0;break;
 405   3          }
 406   2        }
 407   1      }
 408          
 409          /*////////////////////////////////////////////////////////////////////////////*/
 410          // 1ms tick
 411          void isr_PCA() interrupt 7
 412          {
 413   1        CCF0 = 0; //æ¸…é™¤ä¸­æ–­æ ‡å¿—
 414   1        _sys_us += 1000;
 415   1        _sys_ms ++;
 416   1        CCAP0L = _sys_us;
 417   1        CCAP0H = _sys_us >> 8;
 418   1      
 419   1        timer_tick();
 420   1      }
 421          
C51 COMPILER V9.59.0.0   LIB                                                               01/09/2022 02:19:05 PAGE 8   

 422          /*////////////////////////////////////////////////////////////////////////////*/
 423          //å»¶æ—¶å‡½æ•°
 424          void delay_1_ms()   //@12.000MHz
 425          {
 426   1      #if 1
 427   1        unsigned char i, j;
 428   1        i = 12;
 429   1        j = 168;
 430   1        do
 431   1        {
 432   2          while (--j);
 433   2        } while (--i);
 434   1      #else
                delayMicroseconds(1000);  
              #endif
 437   1      }
 438          
 439          void delay(u16 i)
 440          {
 441   1        while(i--)
 442   1        delay_1_ms();
 443   1      }
 444          
 445          #if 1
 446          u16 micros(void)
 447          {
 448   1        u8 H0,H1,L;
 449   1        
 450   1        H0 = CH;
 451   1        L  = CL;
 452   1        H1 = CH;
 453   1        
 454   1        if(H1!=H0) L=0;
 455   1        
 456   1        return ((u16)H1<<8) | L;
 457   1      }
 458          
 459          #if 0
              u32 millis(void)
              {
                u32 temp;
              
                ET0 = 0;
                temp = _sys_ms;
                ET0 = 1;
              
                return temp;
              }
              #endif
 471          
 472          #if 0
              void delayMicroseconds(u16 us)
              {
                //v20220107
                u16 start = micors();
                while(micros()-start<us);
              }
              #endif
 480          
 481          #endif
 482          
 483          /*////////////////////////////////////////////////////////////////////////////*/
C51 COMPILER V9.59.0.0   LIB                                                               01/09/2022 02:19:05 PAGE 9   

 484          //ROMå­˜å‚¨
 485          
 486          u8 EEPROM_read(u16 addr)  //è¯»æ•°æ®
 487          {
 488   1        IAP_CMD=0x01;
 489   1      
 490   1        IAP_ADDRH=addr>>8;
 491   1        IAP_ADDRL=addr; 
 492   1        
 493   1        IAP_TRIG=0x5a;      
 494   1        IAP_TRIG=0xa5;
 495   1        _nop_();
 496   1      
 497   1        return IAP_DATA;
 498   1      }
 499          
 500          void EEPROM_write(u16 addr,u8 byte) //å†™å…¥æ•°æ®
 501          {
 502   1        IAP_CMD=0x02;
 503   1        IAP_DATA=byte;
 504   1      
 505   1        IAP_ADDRH=addr>>8;
 506   1        IAP_ADDRL=addr; 
 507   1      
 508   1        IAP_TRIG=0x5a;
 509   1        IAP_TRIG=0xa5;
 510   1        _nop_();
 511   1      }
 512          
 513          void EEPROM_cleanPage(u8 addrPage)  //æ“¦é™¤æ‰‡åŒºæ•°æ®
 514          {
 515   1        IAP_CMD=0x03;
 516   1      
 517   1        IAP_ADDRH=(SIZE_EEPROM_PAGE*addrPage)>>8;
 518   1        IAP_ADDRL=0;
 519   1      
 520   1        IAP_TRIG=0x5a;
 521   1        IAP_TRIG=0xa5;
 522   1        _nop_();
 523   1      }
 524          
 525          u8 EEPROM_test(void)
 526          {
 527   1        u8 addrPage = 1;
 528   1        
 529   1        EEPROM_begin();
 530   1        
 531   1        EEPROM_cleanPage(addrPage);
 532   1        EEPROM_write(SIZE_EEPROM_PAGE*addrPage,0x88);
 533   1        if(EEPROM_read(SIZE_EEPROM_PAGE*addrPage)!=0x88)  {EEPROM_end();  return 1; }//err
 534   1        EEPROM_cleanPage(addrPage);
 535   1        EEPROM_write(SIZE_EEPROM_PAGE*addrPage,0x55);
 536   1        if(EEPROM_read(SIZE_EEPROM_PAGE*addrPage)!=0x55)  {EEPROM_end();  return 1; }//err
 537   1      
 538   1        return 0; //ok
 539   1      }
 540          
 541          
 542          /*////////////////////////////////////////////////////////////////////////////*/
 543          // soft SPI
 544          #define SPI_MODE_0    (0<<0)
 545          #define SPI_MODE_1    (1<<0)
C51 COMPILER V9.59.0.0   LIB                                                               01/09/2022 02:19:05 PAGE 10  

 546          #define SPI_MODE_2    (2<<0)
 547          #define SPI_MODE_3    (3<<0)
 548          #define SPI_MSBFIRST  (0<<2)
 549          #define SPI_LSBFIRST  (1<<2)
 550          #define SPI_SPEED_SOF (0<<3)
 551          
 552          u8 SPI_begin(u8 setting)
 553          {
 554   1        if(setting!=(SPI_MODE_0|SPI_MSBFIRST)) return 0;
 555   1        
 556   1        // set SCK/MOSI/NSS output mode, MISO input mode
 557   1        // then set SCK/MOSI 0, set NNS 1.
 558   1        SPI_SLAVE_DIS();
 559   1        SPI_SCK_CLR();
 560   1        SPI_MOSI_CLR();
 561   1        return 1;
 562   1      }
 563          
 564          u8 SPI_transfer(u8 byte)
 565          {
 566   1        u8 i;
 567   1        for(i=0;i<8;i++)
 568   1        {
 569   2          if(byte&0x80)
 570   2          {
 571   3            SPI_MOSI_SET();
 572   3          }
 573   2          else
 574   2          {
 575   3            SPI_MOSI_CLR();
 576   3          }
 577   2          SPI_SCK_SET();
 578   2          byte<<=1;
 579   2          byte|=MISO;
 580   2          SPI_SCK_CLR();
 581   2        }
 582   1        return byte;
 583   1      }
 584          
 585          void SPI_slaveEnable(void)
 586          {
 587   1        SPI_SLAVE_EN();
 588   1      }
 589          
 590          void SPI_slaveDisable(void)
 591          {
 592   1        SPI_SLAVE_DIS();
 593   1      }
 594          
 595          /*
 596          void SPI_end(void)
 597          {
 598          
 599          }
 600          */
 601          
 602          /*////////////////////////////////////////////////////////////////////////////*/
 603          //NRF24L01
 604          
 605          void NRF_REG_write(u8 address,u8 command)
 606          {
 607   1        SPI_slaveEnable();
C51 COMPILER V9.59.0.0   LIB                                                               01/09/2022 02:19:05 PAGE 11  

 608   1        SPI_transfer(0x20+address);
 609   1        SPI_transfer(command);
 610   1        SPI_slaveDisable();
 611   1      }
 612          
 613          void NRF_FIFO_write(u8 DATA_OUT[],u8 lengh)
 614          {
 615   1        u8 i;
 616   1      
 617   1        SPI_slaveEnable();
 618   1        SPI_transfer(0xa0);
 619   1        for(i=0;i<lengh;i++) SPI_transfer(DATA_OUT[i]);
 620   1        SPI_slaveDisable();
 621   1      }
 622          void NRF_FIFO_read(u8 DATA_IN[],u8 lengh)
 623          {
 624   1        u8 i;
 625   1      
 626   1        SPI_slaveEnable();
 627   1        SPI_transfer(0x61); //è¯»å–å‘½ä»¤
 628   1        for(i=0;i<lengh;i++) DATA_IN[i]=SPI_transfer(0);     
 629   1        SPI_slaveDisable();
 630   1      }
 631          
 632          void NRF_addr_tx(u8 DATA_IN[])
 633          {
 634   1        SPI_slaveEnable();
 635   1        SPI_transfer(0x20+0x10);
 636   1        SPI_transfer(DATA_IN[0]);
 637   1        SPI_transfer(DATA_IN[1]);
 638   1        SPI_transfer(DATA_IN[2]);
 639   1        SPI_transfer(DATA_IN[3]);
 640   1        SPI_transfer(DATA_IN[4]);
 641   1        SPI_slaveDisable();
 642   1      }  
 643          void NRF_addr_rx(u8 DATA_IN[])
 644          {
 645   1        SPI_slaveEnable();
 646   1        SPI_transfer(0x20+0x0a);
 647   1        SPI_transfer(DATA_IN[0]);
 648   1        SPI_transfer(DATA_IN[1]);
 649   1        SPI_transfer(DATA_IN[2]);
 650   1        SPI_transfer(DATA_IN[3]);
 651   1        SPI_transfer(DATA_IN[4]);
 652   1        SPI_slaveDisable();
 653   1      }
 654          void NRF_mode_rx()         
 655          {
 656   1        NRF_CE_CLR();
 657   1        NRF_REG_write(0x00,0x3b); //CRC,8 bit,Power on,RX
 658   1        NRF_CE_SET();
 659   1      }            
 660            
 661          void NRF_mode_tx()         
 662          {
 663   1        NRF_CE_CLR();
 664   1        NRF_REG_write(0x00,0x0a);
 665   1        NRF_CE_SET();
 666   1      }
 667          
 668          void  NRF_power(u8 P)       //å‘å°„åŠŸç‡è®¾ç½® 250k
 669          {                           
C51 COMPILER V9.59.0.0   LIB                                                               01/09/2022 02:19:05 PAGE 12  

 670   1        NRF_CE_CLR();
 671   1        if(P==3)     NRF_REG_write(0x06,0x27);      //0db ä¿®æ­£ä¹‹å‰æ³¨é‡Šé”™è¯¯
 672   1        else if(P==2)NRF_REG_write(0x06,0x25);    //-6db
 673   1        else if(P==1)NRF_REG_write(0x06,0x23);    //-12db
 674   1        else if(P==0)NRF_REG_write(0x06,0x21);    //-18db
 675   1        NRF_CE_SET();
 676   1      }
 677          
 678          void NRF_size(u8 l)
 679          {
 680   1        NRF_CE_CLR();
 681   1        NRF_REG_write(0x11,l);  
 682   1        NRF_CE_SET();
 683   1      }
 684          
 685          void NRF_channel(u8 c)
 686          {
 687   1        NRF_CE_CLR();
 688   1        NRF_REG_write(0x05,c);  
 689   1        NRF_CE_SET();
 690   1      }
 691          
 692          void NRF_init_0(void)
 693          {
 694   1        NRF_CE_CLR();
 695   1        //  NRF_REG_write(0x00,0x0a); //CRCä½¿èƒ½ï¼Œä¸Šç”µ
 696   1        NRF_REG_write(0x01,0x00); //ç¦æ­¢ è‡ªåŠ¨åº”ç­”
 697   1        NRF_REG_write(0x02,0x01); //å…è®¸ P0ä¿¡é“
 698   1        NRF_REG_write(0x04,0x00); //ç¦æ­¢ è‡ªåŠ¨é‡å‘
 699   1        NRF_CE_SET();
 700   1      }
 701          
 702          void NRF_irq_clean(void)
 703          {
 704   1          NRF_CE_CLR();
 705   1          //NRF_REG_write(0x07,0x40); //æ¸…é™¤æ— çº¿æ¨¡å—æ¥æ”¶æ•°æ®ä¸­æ–­ä¿¡å·
 706   1          NRF_REG_write(0x07,0x70); //æ¸…é™¤æ— çº¿æ¨¡å—ï¼ˆé‡å‘å¤±è´¥+å‘é€å®Œæˆ+æ•°æ®æ¥å—ï¼‰ä¸­æ–­ä¿¡å·
 707   1      
 708   1          NRF_CE_SET();
 709   1      }
 710          
 711          void NRF_init(void) //u8 ch,u8 address[])
 712          {
 713   1        
 714   1        SPI_begin(0);
 715   1        
 716   1        NRF_init_0();
 717   1        NRF_mode_rx();
 718   1      //  NRF_channel(ch);
 719   1        NRF_power(0);
 720   1        NRF_size(LOLI3_NRF_DATA_LENGTH);
 721   1      //  NRF_addr_rx(address);
 722   1      //  NRF_addr_tx(address);
 723   1      }
 724          
 725          #define NRF_BAD_CSNCLK  0x01
 726          #define NRF_BAD_MOSI    0x02
 727          #define NRF_BAD_CE      0x04
 728          #define NRF_BAD_IRQ     0x08
 729          #define NRF_BAD_MISO    0x10
 730          
 731          
C51 COMPILER V9.59.0.0   LIB                                                               01/09/2022 02:19:05 PAGE 13  

 732          u8 NRF_test() //æ— çº¿æ¨¡å—ç»ˆææµ‹è¯•
 733          { 
 734   1        u8 reset_err=0;
 735   1        u8 NRF_error = 0;
 736   1        u8 tx[1] = {'T'}; // test?
 737   1      
 738   1        SPI_begin(0);
 739   1        NRF_CE_CLR();
 740   1      
 741   1        SPI_slaveEnable();
 742   1        if(SPI_transfer(0x20)!=0x0e){reset_err=1;}
 743   1        SPI_transfer(0x0a);
 744   1        SPI_slaveDisable();
 745   1        
 746   1        SPI_slaveEnable();
 747   1        SPI_transfer(0x00);
 748   1        if(SPI_transfer(0x00)!=0x0a){NRF_error|=NRF_BAD_MOSI;}//MOSI bad
 749   1        SPI_slaveDisable();
 750   1      
 751   1        NRF_REG_write(0x01,0x00);
 752   1        NRF_REG_write(0x04,0x00);
 753   1        NRF_REG_write(0x11,1);
 754   1        NRF_FIFO_write(tx,1);
 755   1      
 756   1        NRF_CE_SET();
 757   1      
 758   1        delay(2);
 759   1        
 760   1        SPI_slaveEnable();
 761   1        if(SPI_transfer(0x00)!=0x2e){NRF_error|=NRF_BAD_CE;}//CE bad
 762   1        SPI_slaveDisable();
 763   1          
 764   1      
 765   1        if(noRF) NRF_error|=NRF_BAD_IRQ;  //IRQ bad. bug fix?: 0x18->0x08
 766   1        else 
 767   1        {
 768   2          if(NRF_error&0x04==0)NRF_error|=NRF_BAD_MISO;   //MISO bad
 769   2        }
 770   1        NRF_CE_SET();
 771   1        
 772   1        if(reset_err&&NRF_error>1)NRF_error|=NRF_BAD_CSNCLK;//CSN,CLK bad
 773   1        
 774   1        NRF_irq_clean();
 775   1        
 776   1        return NRF_error;
 777   1      }
 778          
 779          /*////////////////////////////////////////////////////////////////////////////*/
 780          
 781          void LED_on(void)
 782          {
 783   1        LED_ON();
 784   1      }
 785          
 786          void LED_off(void)
 787          {
 788   1        LED_OFF();
 789   1      }
 790          
 791          void LED_flash(u8 t)
 792          {
 793   1        while(t)
C51 COMPILER V9.59.0.0   LIB                                                               01/09/2022 02:19:05 PAGE 14  

 794   1        {
 795   2          LED_ON();   
 796   2          delay(50);
 797   2          LED_OFF();    
 798   2          delay(50);
 799   2          t--;
 800   2        }
 801   1      }
 802          
 803          /*////////////////////////////////////////////////////////////////////////////*/
 804          
 805          void UART_init(u8 bps)
 806          {
 807   1        SCON = 0xD0;    //9ä½æ•°æ®,å¯å˜æ³¢ç‰¹ç‡
 808   1        AUXR |= 0x01;   //ä¸²å£1é€‰æ‹©å®šæ—¶å™¨2ä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨
 809   1        AUXR |= 0x04;   //å®šæ—¶å™¨2æ—¶é’Ÿä¸ºFosc,å³1T
 810   1      
 811   1        if(bps==UART_BPS_9600)  //9600bps@12.000MHz
 812   1        {
 813   2          T2L = 0xC7;
 814   2          T2H = 0xFE;
 815   2        }
 816   1        else if(bps==UART_BPS_115200) //115200bps@12.000MHz
 817   1        {
 818   2          T2L = 0xE6;   //è®¾ç½®å®šæ—¶åˆå§‹å€¼
 819   2          T2H = 0xFF;   //è®¾ç½®å®šæ—¶åˆå§‹å€¼
 820   2        }
 821   1        else      //100000bps@12.000MHz
 822   1        {
 823   2          T2L = 0xE2;   //è®¾å®šå®šæ—¶åˆå€¼
 824   2          T2H = 0xFF;   //è®¾å®šå®šæ—¶åˆå€¼
 825   2        }
 826   1      
 827   1        PIN_SBUS = 1;   //ä¸Šæ‹‰è¾“å‡ºç«¯å£ï¼Ÿæœ‰æ— å¿…è¦ï¼Ÿ
 828   1        AUXR |= 0x10;   //å®šæ—¶å™¨2å¼€å§‹è®¡æ—¶
 829   1      }
 830          
 831          void UART_pushByte(u8 c)
 832          {
 833   1          if(TI)TI=0;
 834   1          ACC=c;
 835   1          TB8=P;
 836   1          SBUF=ACC;
 837   1      }
 838          
 839          char* Int16ToStr(u16 i)
 840          {
 841   1        u8 t;
 842   1        static xdata char str[7];
 843   1      
 844   1        str[0] = '0';
 845   1        str[1] = 'x';
 846   1        t=i>>12;
 847   1        if(t<10) str[2]=(t+'0');
 848   1        else     str[2]=(t+'A'-10);
 849   1        t=(i>>8)&0x0F;
 850   1        if(t<10) str[3]=(t+'0');
 851   1        else     str[3]=(t+'A'-10);
 852   1        t=(i>>4)&0x0F;
 853   1        if(t<10) str[4]=(t+'0');
 854   1        else     str[4]=(t+'A'-10);
 855   1        t=(i>>0)&0x0F;
C51 COMPILER V9.59.0.0   LIB                                                               01/09/2022 02:19:05 PAGE 15  

 856   1        if(t<10) str[5]=(t+'0');
 857   1        else     str[5]=(t+'A'-10);
 858   1        str[6] = '\0';
 859   1      
 860   1        return str;
 861   1      }
 862          
 863          void UART_puts(char* str)
 864          {
 865   1        while(*str)
 866   1        {
 867   2          UART_pushByte(*str++);
 868   2          while(!TI); // bugfix:20211220: å°†æ­¤å¥ç§»åˆ°UART_pushByte()åé¢ï¼Œé˜²æ­¢æ­»å¾ªç¯ã€‚å‰¯ä½œç”¨æ˜¯å‡½
             -æ•°å¤–éƒ¨ä¹‹å‰ä½¿ç”¨UART_pushByte()å¯èƒ½æœªå‘é€å®Œæˆå°±è¢«ç»ˆæ­¢ã€‚
 869   2        }
 870   1        UART_pushByte('\r');
 871   1        while(!TI);
 872   1        UART_pushByte('\n');
 873   1        while(!TI);
 874   1      }
 875          
 876          /*////////////////////////////////////////////////////////////////////////////*/
 877          
 878          static STimer* _pTimers;
 879          static u8 _numTimers;
 880          
 881          void timer_init(STimer* pTimers, u8 numTimers)
 882          {
 883   1        u8 i;
 884   1      
 885   1        _pTimers = pTimers;
 886   1        _numTimers = numTimers;
 887   1        
 888   1        for(i=0; i<_numTimers; i++) // stop all the timers to prevent exception
 889   1        {
 890   2          _pTimers[i].isRuning  = 0;    // prevent timers change by <timers_tick>
 891   2          _pTimers[i].isTimeout = 0;    // prevent timers call by <timers_process>
 892   2          _pTimers[i].count      = 0;
 893   2          _pTimers[i].reload   = 0;
 894   2          _pTimers[i].callback  = 0;
 895   2        }
 896   1      }
 897          
 898          void timer_cbRegist(u8 index, void (*callback)(void))
 899          {
 900   1      //  _pTimers[index].isRuning = 0;
 901   1      //  _pTimers[index].isTimeout = 0;
 902   1      //  _pTimers[index].count = 0;
 903   1      //  _pTimers[index].reload = 0;
 904   1        _pTimers[index].callback = callback;
 905   1      }
 906          
 907          void timer_startOnce(u8 index, u16 ms)
 908          {
 909   1        _pTimers[index].isRuning = 0; // stop the timer to prevent exception
 910   1        _pTimers[index].isTimeout = 0;
 911   1        _pTimers[index].count = ms;
 912   1        _pTimers[index].reload = 0;
 913   1        _pTimers[index].isRuning = 1; // start the timer
 914   1      }
 915          
 916          void timer_startTimes(u8 index, u16 ms, u8 times)
C51 COMPILER V9.59.0.0   LIB                                                               01/09/2022 02:19:05 PAGE 16  

 917          {
 918   1        _pTimers[index].isRuning = 0; // stop the timer to prevent exception
 919   1        _pTimers[index].isTimeout = 0;
 920   1        _pTimers[index].count = timer[index].reload = ms;
 921   1        _pTimers[index].isRuning = times; // start the timer
 922   1      }
 923          
 924          void timer_startCycle(u8 index, u16 ms)
 925          {
 926   1        timer_startTimes(index, ms, 0xff);
 927   1      }
 928          
 929          void timer_tick() // called by ISR
 930          {
 931   1        static u8 step=0;
 932   1        u8 i;
 933   1      
 934   1        step++;
 935   1        if(step < TIMERS_TICK_SETPS) return;
 936   1        step = 0;
 937   1      
 938   1        for(i=0;i<_numTimers;i++)
 939   1        {
 940   2          if(_pTimers[i].isRuning)
 941   2          {
 942   3            if(_pTimers[i].count>TIMERS_TICK_SETPS) _pTimers[i].count -= TIMERS_TICK_SETPS;
 943   3            else
 944   3            {
 945   4              _pTimers[i].count = _pTimers[i].reload;
 946   4              if(_pTimers[i].isRuning != 0xFF) _pTimers[i].isRuning--;
 947   4              if(_pTimers[i].reload==0) _pTimers[i].isRuning = 0;
 948   4              _pTimers[i].isTimeout = 1;
 949   4            }
 950   3          }
 951   2        }
 952   1      }
 953          
 954          void timer_process()
 955          {
 956   1        u8 i;
 957   1      
 958   1        for(i=0;i<_numTimers;i++)
 959   1        {
 960   2          if(_pTimers[i].isTimeout)
 961   2          {
 962   3            _pTimers[i].isTimeout = 0;
 963   3            if(_pTimers[i].callback) _pTimers[i].callback();
 964   3          }
 965   2        }
 966   1      
 967   1      }
 968          
 969          /******************************************************************************/
 970          /*-DO NOT ADD YOUR CODE AFTER HERE!-*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\-WIDTH: 80-*/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2987    ----
   CONSTANT SIZE    =      1    ----
   XDATA SIZE       =      7    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     14      22
C51 COMPILER V9.59.0.0   LIB                                                               01/09/2022 02:19:05 PAGE 17  

   IDATA SIZE       =      6    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
