C51 COMPILER V9.59.0.0   APP                                                               01/09/2022 02:19:05 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE APP
OBJECT MODULE PLACED IN .\Objects\app.obj
COMPILER INVOKED BY: C:\bin\Keil_v5\C51\BIN\C51.EXE app.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\a
                    -pp.lst) TABS(2) OBJECT(.\Objects\app.obj)

line level    source

   1          /*
   2          ********************************************************************************
   3          *                             ---ofme---
   4          *           Copyleft (c) 2021, 微风山谷 / ofourme@163.com
   5          *           License: LGPL
   6          *
   7          *   APP.C-V0.6.0 (2021.Dec.26th)
   8          *
   9          ********************************************************************************
  10          */
  11          
  12          #define __APP_C__
  13          
  14          /*-DO NOT ADD YOUR CODE BEFORE HERE!-*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\-WIDTH: 80-*/
  15          /******************************************************************************/
  16          
  17          #include "lib.h"
  18          #include "app.h"
  19          
  20          /*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
  21          
  22          
  23          /*////////////////////////////////////////////////////////////////////////////*/
  24          
  25          const u8 code _random_hopping_index[100]={
  26                    4,1,3,2,2,1,0,0,2,2,2,3,4,1,2,1,4,3,3,4,//随机跳频序列
  27                    2,0,2,2,3,1,2,3,2,2,2,4,2,4,0,3,4,2,3,1,
  28                    0,3,1,3,3,0,2,0,4,3,3,3,3,3,4,1,1,4,3,0,
  29                    1,0,3,2,3,2,3,3,4,4,1,3,0,0,3,1,3,3,3,0,
  30                    3,3,4,1,2,4,1,3,0,1,3,4,4,3,2,3,1,2,3,3};
  31          
  32          const u8 code recv_address_startup[5]={LOLI3_ADDRESS_STARTUP};
  33          
  34          Loli3RecvSet xdata  recvSet = {0,LOLI3_HOPPING_STARTUP,LOLI3_ADDRESS_STARTUP,0,511,511,80,511,511,511,511,5
             -11};
  35          Loli3RecvData   recv  = {0,1023,0,1023,0,1023,0,0};
  36          Loli3RecvNrf  xdata nrf   = {0};
  37          
  38          enum {STATE_LED_OFF=0, STATE_LED_FLASH, STATE_LED_ON, STATE_LED_IDLE} E_STATE_LED;
  39          enum {STATE_NRF_INIT=0, STATE_NRF_RX, STATE_NRF_TX, STATE_NRF_TX_WAIT, STATE_NRF_DATA_PROC} E_STATE_NRF;
  40          enum {TIMER_LED_FLASH=0, TIMER_SIGNAL_COUNT, TIMER_SIGNAL_LOST, TIMER_DATA_SAVE,  TIMER_LED_OFF, TIMER_CHA
             -NNEL_LOST, TIMER_ADC, NUM_TIMERS} E_TIMER;
  41          
  42          STimer idata timer[NUM_TIMERS];
  43          
  44          u16 _adc_ic,_adc_batt;
  45          
  46          
  47          /*////////////////////////////////////////////////////////////////////////////*/
  48          
  49          #define MAGIC_RECV_SET  0xab
  50          
  51          void DATA_read()
  52          {
C51 COMPILER V9.59.0.0   APP                                                               01/09/2022 02:19:05 PAGE 2   

  53   1        u8 i;
  54   1        u16 sum,sum_read;
  55   1        u8* set;
  56   1      
  57   1        recvSet.isValid = 0;
  58   1        EEPROM_begin();
  59   1        if( EEPROM_read(0)!= MAGIC_RECV_SET )
  60   1        {
  61   2          EEPROM_end();
  62   2          return;
  63   2        }
  64   1      
  65   1        sum = MAGIC_RECV_SET;
  66   1        for(i=1,set=(u8*)&recvSet+1;i<sizeof(Loli3RecvSet);i++)
  67   1        {
  68   2          *set=EEPROM_read(i);
  69   2          sum+=*set++;
  70   2        }
  71   1      
  72   1        sum_read=EEPROM_read(sizeof(Loli3RecvSet));//读校验和
  73   1        sum_read<<=8;
  74   1        sum_read+=EEPROM_read(sizeof(Loli3RecvSet)+1);
  75   1      
  76   1        EEPROM_end();
  77   1      
  78   1        if(sum!=sum_read) return; //比较校验和
  79   1        recvSet.isValid = MAGIC_RECV_SET;
  80   1        return;
  81   1      }
  82          
  83          void DATA_save()
  84          {
  85   1        u8 i;
  86   1        u16 sum;
  87   1        u8* set;
  88   1      
  89   1        EEPROM_begin();
  90   1        EEPROM_cleanPage(0);
  91   1        recvSet.isValid = MAGIC_RECV_SET;
  92   1        for(i=0,sum=0,set=(u8*)&recvSet;i<sizeof(Loli3RecvSet);i++)
  93   1        {
  94   2          EEPROM_write(i,*set);
  95   2          sum+=*set++;
  96   2        }
  97   1        EEPROM_write(sizeof(Loli3RecvSet),sum>>8);
  98   1        EEPROM_write(sizeof(Loli3RecvSet)+1,sum);
  99   1      
 100   1        EEPROM_end();
 101   1      }
 102          
 103          #undef MAGIC_RECV_SET
 104          
 105          /*////////////////////////////////////////////////////////////////////////////*/
 106          
 107          void SBUS_data_push()
 108          {
 109   1        u8 i;
 110   1        u8 buff[12];
 111   1      
 112   1        buff[1] =                (u8)(recv.CH_data[0])<<1;
 113   1        buff[2] = (u8)(recv.CH_data[0]>>7)+(u8)(recv.CH_data[1])<<4;
 114   1        buff[3] = (u8)(recv.CH_data[1]>>4)+(u8)(recv.CH_data[2])<<7;
C51 COMPILER V9.59.0.0   APP                                                               01/09/2022 02:19:05 PAGE 3   

 115   1        buff[4] = (u8)(recv.CH_data[2]>>1);
 116   1        buff[5] = (u8)(recv.CH_data[2]>>9)+(u8)(recv.CH_data[3])<<2;
 117   1        buff[6] = (u8)(recv.CH_data[3]>>6)+(u8)(recv.CH_data[4])<<5;
 118   1        buff[7] = (u8)(recv.CH_data[4]>>3)+(u8)(recv.CH_data[5])<<8;
 119   1        buff[8] = (u8)(recv.CH_data[5]);
 120   1        buff[9] = (u8)(recv.CH_data[5]>>8)+(u8)(recv.CH_data[6])<<3;
 121   1        buff[10]= (u8)(recv.CH_data[6]>>5)+(u8)(recv.CH_data[7])<<6;
 122   1        buff[11]= (u8)(recv.CH_data[7]>>2);
 123   1      
 124   1        recv.SBUS_tx[0]=0x0f; //Star
 125   1        DATA_mutex_get();     //防止修改SBUS数据的时候，中断程序在端口输出错误数据
 126   1        for(i=1 ; i<=11; i++) //CH1~CH8
 127   1        {
 128   2          recv.SBUS_tx[i]=buff[i];
 129   2        }
 130   1        DATA_mutex_release();
 131   1        for(    ; i<=22; i++) //CH9~CH16
 132   1        {
 133   2          recv.SBUS_tx[i]=0;
 134   2        }
 135   1        recv.SBUS_tx[23]=0;   //flag
 136   1        recv.SBUS_tx[24]=0;   //End
 137   1      }
 138          
 139          /*////////////////////////////////////////////////////////////////////////////*/
 140          
 141          void callback_timer_signal_count(void)
 142          {
 143   1          recv.rx_num=nrf.rx_cnt;
 144   1          nrf.rx_cnt=0;
 145   1      }
 146          
 147          void callback_timer_signal_lost(void)
 148          {
 149   1        u8 i;
 150   1      
 151   1        DBG("LOLI3 recv signal lost!!!");
 152   1        recv.stateLED = STATE_LED_ON;
 153   1      
 154   1        DATA_mutex_get();
 155   1        for(i=0; i<8; i++)
 156   1        {
 157   2          recv.CH_data[i]=recvSet.out_control_data[i];
 158   2        }
 159   1        DATA_mutex_release();
 160   1      
 161   1        SBUS_data_push();
 162   1      }
 163          
 164          void callback_timer_data_save(void)
 165          {
 166   1        DATA_save();
 167   1        recv.stateLED = STATE_LED_FLASH;
 168   1      }
 169          
 170          void callback_timer_led_off(void)
 171          {
 172   1        recv.stateLED = STATE_LED_OFF;
 173   1      }
 174          
 175          void callback_timer_channel_lost(void)
 176          {
C51 COMPILER V9.59.0.0   APP                                                               01/09/2022 02:19:05 PAGE 4   

 177   1        static u8 index = 0;
 178   1      
 179   1        if( noRF )
 180   1        {
 181   2          nrf.hopping_cnt++;
 182   2          if(nrf.hopping_cnt>LOLI3_NUM_HOPPING)
 183   2          {
 184   3            if(index>=   (sizeof(_random_hopping_index)/sizeof(_random_hopping_index[0])) ) index=0;
 185   3            nrf.channel_index =  _random_hopping_index[index++];
 186   3          }
 187   2          else
 188   2          {
 189   3            nrf.channel_index++;
 190   3            if(nrf.channel_index>=LOLI3_NUM_HOPPING)nrf.channel_index=0;
 191   3          }
 192   2          NRF_channel(recvSet.hopping[nrf.channel_index]);
 193   2        }
 194   1      }
 195          
 196          void callback_timer_adc(void)
 197          {
 198   1        static u8 i=0;
 199   1        u16 adc;
 200   1      
 201   1        adc = adc_read();
 202   1        i++;
 203   1        if(i&0x01)
 204   1        {
 205   2          _adc_ic = adc + ((_adc_ic*7)>>3); //扩大8倍
 206   2          adc_open(1);
 207   2        }
 208   1        else
 209   1        {
 210   2          _adc_batt = adc + ((_adc_batt*7)>>3); //扩大8倍
 211   2          adc_open(0);
 212   2        }
 213   1      }
 214          
 215          void timers_init()
 216          {
 217   1        timer_init(timer, NUM_TIMERS);
 218   1      
 219   1        timer_cbRegist(TIMER_SIGNAL_COUNT,callback_timer_signal_count);
 220   1        timer_cbRegist(TIMER_SIGNAL_LOST, callback_timer_signal_lost);
 221   1        timer_cbRegist(TIMER_DATA_SAVE,   callback_timer_data_save);
 222   1        timer_cbRegist(TIMER_LED_OFF,     callback_timer_led_off);
 223   1        timer_cbRegist(TIMER_CHANNEL_LOST,callback_timer_channel_lost);
 224   1        timer_cbRegist(TIMER_ADC,         callback_timer_adc);
 225   1      }
 226          
 227          
 228          /*////////////////////////////////////////////////////////////////////////////*/
 229          
 230          void NRF_read(void)
 231          {
 232   1        NRF_FIFO_read(nrf.rx, LOLI3_NRF_DATA_LENGTH);
 233   1      }
 234          
 235          void NRF_write(void)
 236          {
 237   1        NRF_FIFO_write(nrf.tx,LOLI3_NRF_DATA_LENGTH);
 238   1      }
C51 COMPILER V9.59.0.0   APP                                                               01/09/2022 02:19:05 PAGE 5   

 239          
 240          /*////////////////////////////////////////////////////////////////////////////*/
 241          
 242          void recv_connect()
 243          {
 244   1          NRF_channel(LOLI3_CHANNEL_CONNECT);
 245   1          NRF_addr_rx(recvSet.address);
 246   1          NRF_addr_tx(recvSet.address);
 247   1          NRF_power(3);
 248   1      }
 249          
 250          void recv_reconnect()
 251          {
 252   1        u8 i,t;
 253   1      
 254   1        NRF_channel(LOLI3_CHANNEL_STARTUP);
 255   1        NRF_addr_tx(recv_address_startup);
 256   1        NRF_addr_rx(recv_address_startup);
 257   1      
 258   1        do
 259   1        {
 260   2          while(noRF);
 261   2          NRF_read();
 262   2          NRF_irq_clean();
 263   2      
 264   2        } while(nrf.rx[0]!=0xa0);
 265   1      
 266   1      
 267   1        for(i=0,t=1; i<LOLI3_NUM_HOPPING; i++,t++)
 268   1        {
 269   2          recvSet.hopping[i]=nrf.rx[t];
 270   2        }
 271   1        for(i=0; i<5; i++,t++)
 272   1        {
 273   2          recvSet.address[i]=nrf.rx[t];
 274   2        }
 275   1        nrf.tx[0]='O',nrf.tx[1]='K';
 276   1      
 277   1        while(1)
 278   1        {
 279   2          NRF_mode_tx();
 280   2          NRF_channel(LOLI3_CHANNEL_STARTUP);
 281   2          NRF_addr_tx(recv_address_startup);
 282   2          NRF_addr_rx(recv_address_startup);
 283   2          NRF_write();
 284   2          delay_1_ms();
 285   2      
 286   2          NRF_mode_rx();
 287   2          NRF_channel(recvSet.hopping[0]);
 288   2          NRF_addr_tx(recvSet.address);
 289   2          NRF_addr_rx(recvSet.address);
 290   2          for(t=100; t--; )
 291   2          {
 292   3            delay_1_ms();
 293   3            if(noRF==0) // 接收到信号
 294   3            {
 295   4              NRF_read();
 296   4              NRF_irq_clean();
 297   4              DATA_save();
 298   4              NRF_power(3);
 299   4              return;
 300   4            }
C51 COMPILER V9.59.0.0   APP                                                               01/09/2022 02:19:05 PAGE 6   

 301   3          }
 302   2        }
 303   1      }
 304          
 305          /*////////////////////////////////////////////////////////////////////////////*/
 306          
 307          void recv_init()
 308          {
 309   1        u8 restar = 0;
 310   1        u8 temp;
 311   1      
 312   1        port_ch5_mode_OUTPUT();
 313   1        port_ch6_mode_INPUT_PULLUP();
 314   1        port_ch5_clr();
 315   1        delay_1_ms();
 316   1        if(port_ch6_get()==0) //如果CH5与CH6被短接，重新对码
 317   1        {
 318   2          port_ch5_set();   // 插上舵机会拉低CH6电平。改变CH5电平，确认CH5与CH6短接。
 319   2          delay_1_ms();
 320   2          if(port_ch6_get())    LED_flash(20), restar=1;   //启动重新对码
 321   2        }
 322   1        port_chs_mode_OUTPUT();
 323   1      
 324   1        while(EEPROM_test())
 325   1        {
 326   2          LED_flash(3);
 327   2          DBG("EEPROM error!");
 328   2          delay(1000);
 329   2        }
 330   1        DATA_read();
 331   1      
 332   1        temp = NRF_test();
 333   1        while(temp)
 334   1        {
 335   2          LED_flash(10);
 336   2          DBG("NRF24L01 error!");
 337   2          DBG(Int16ToStr(temp));
 338   2          delay(1000);
 339   2          temp = NRF_test();
 340   2        }
 341   1      
 342   1        NRF_init();
 343   1        if(restar || recvSet.isValid==0)
 344   1        {
 345   2          DBG("LOLI3 recv reconnecting...");
 346   2          recv_reconnect();
 347   2        }
 348   1        else
 349   1        {
 350   2          DBG("LOLI3 recv connecting...");
 351   2          recv_connect();
 352   2        }
 353   1      
 354   1        recv.stateLED = STATE_LED_OFF;
 355   1        recv.stateNRF = STATE_NRF_INIT;
 356   1      }
 357          
 358          
 359          void recv_begin(void)
 360          {
 361   1        if(recvSet.CH1_PWM) pwm_en(1);
 362   1        if(recvSet.CH2_PWM) pwm_en(2);
C51 COMPILER V9.59.0.0   APP                                                               01/09/2022 02:19:05 PAGE 7   

 363   1      
 364   1        output_en();
 365   1        tick_en();
 366   1        INTERRUPT_en();
 367   1      }
 368          
 369          
 370          /*////////////////////////////////////////////////////////////////////////////*/
 371          
 372          void setup(void)
 373          {
 374   1        port_init();
 375   1        LED_on();
 376   1        delay(500);//开机延时以避过电源波动
 377   1      
 378   1        hw_init();
 379   1      
 380   1        timers_init();
 381   1        timer_startCycle(TIMER_ADC, 50);
 382   1        timer_startCycle(TIMER_SIGNAL_COUNT,1000);
 383   1        DBG("LOLI3 recv start up.");
 384   1        recv_init();
 385   1        LED_off();    //点亮指示灯再关闭，表示单片机正常工作
 386   1        DBG("LOLI3 recv connected.");
 387   1        NRF_channel(recvSet.hopping[0]);
 388   1        while(noRF);
 389   1        recv_begin();
 390   1      }
 391          
 392          void loop (void)
 393          {
 394   1        u16 buff[8];
 395   1        u8 i;
 396   1        static u16 t1,t2;
 397   1      
 398   1          timer_process();
 399   1      
 400   1          switch(recv.stateLED)
 401   1          {
 402   2            case STATE_LED_OFF:
 403   2              LED_off();
 404   2              recv.stateLED = STATE_LED_IDLE;
 405   2              break;
 406   2            case STATE_LED_FLASH:
 407   2              LED_on();
 408   2              timer_startOnce(TIMER_LED_OFF,10);
 409   2              recv.stateLED = STATE_LED_IDLE;
 410   2              break;
 411   2            case STATE_LED_ON:
 412   2              LED_on();
 413   2              break;
 414   2            case STATE_LED_IDLE:
 415   2              break;
 416   2            default:
 417   2              break;
 418   2          }
 419   1      
 420   1          switch(recv.stateNRF)
 421   1          {
 422   2            case STATE_NRF_RX:
 423   2              if(noRF) break;
 424   2            
C51 COMPILER V9.59.0.0   APP                                                               01/09/2022 02:19:05 PAGE 8   

 425   2              if(recv.stateLED ==STATE_LED_ON) recv.stateLED = STATE_LED_OFF;
 426   2      
 427   2              nrf.rx_cnt++;
 428   2              nrf.hopping_cnt=0;//收到有效信号后刷新跳频器
 429   2      
 430   2              timer_startOnce(TIMER_SIGNAL_LOST, 2000);
 431   2              timer_startCycle(TIMER_CHANNEL_LOST, 24); //3*7~3*8
 432   2      
 433   2              NRF_read();   //读取接收数据
 434   2              NRF_irq_clean();
 435   2      
 436   2              NRF_mode_tx();
 437   2              recv.stateNRF = STATE_NRF_TX;
 438   2              //break;
 439   2            case STATE_NRF_TX:
 440   2              nrf.tx[0]=recv.rx_num;
 441   2              #define BGV5  260
 442   2              recv.voltage_ic=(5ul*100*8)*BGV5/_adc_ic;  // 详见《STC15》P898说明，此处输出voltage扩大1
             -00倍，输入adc值扩大8倍，故*100*8
 443   2              nrf.tx[1]=recv.voltage_ic>>8;
 444   2              nrf.tx[2]=recv.voltage_ic;
 445   2              recv.voltage_batt=((long)_adc_batt*recv.voltage_ic*3)>>13;
 446   2              nrf.tx[3]=recv.voltage_batt>>8;
 447   2              nrf.tx[4]=recv.voltage_batt;
 448   2              NRF_write();
 449   2      
 450   2              recv.stateNRF = STATE_NRF_TX_WAIT;
 451   2              t1 = micros();
 452   2              //break;
 453   2            case STATE_NRF_TX_WAIT:
 454   2              t2 = micros()-t1;
 455   2              if(!noRF || t2>=1000) // wait about 0.72ms for TX_DS irq
 456   2              {
 457   3                if(t2>=1000) DBG(Int16ToStr(t2)); // timeout
 458   3                NRF_mode_rx();  // NRF_irq_clean(); change mode would clean irq.
 459   3                recv.stateNRF = STATE_NRF_DATA_PROC;
 460   3              }
 461   2              break;
 462   2            case STATE_NRF_DATA_PROC:
 463   2              nrf.channel_index++;
 464   2              if(nrf.channel_index>4)nrf.channel_index=0;
 465   2              NRF_channel(recvSet.hopping[nrf.channel_index]);
 466   2      
 467   2              if(nrf.rx[0]==0xa2)
 468   2              {
 469   3                if(nrf.rx[1]&0x80)  { recvSet.PPM=1;  }
 470   3                else                { recvSet.PPM=0;  }
 471   3                if(nrf.rx[1]&0x40)  { recvSet.SBUS=1;     }
 472   3                else                { recvSet.SBUS=0;     }
 473   3                if(nrf.rx[1]&0x08)  { recvSet.CH1_PWM=1; pwm_en(1); }
 474   3                else                { recvSet.CH1_PWM=0; pwm_dis(1);}
 475   3                if(nrf.rx[1]&0x04)  { recvSet.CH2_PWM=1; pwm_en(2); }
 476   3                else                { recvSet.CH2_PWM=0; pwm_dis(2);}
 477   3                if(nrf.rx[1]&0x02)  { recvSet.CH7_PWM=1;  }//pwm_ch7_en(); }
 478   3                else                { recvSet.CH7_PWM=0;  }//pwm_ch7_dis();}
 479   3                if(nrf.rx[2]&0x80)  { recvSet.CH1_SW=1;   }
 480   3                else                { recvSet.CH1_SW=0;   }
 481   3                if(nrf.rx[2]&0x40)  { recvSet.CH2_SW=1;   }
 482   3                else                { recvSet.CH2_SW=0;   }
 483   3                if(nrf.rx[2]&0x20)  { recvSet.CH3_SW=1;   }
 484   3                else                { recvSet.CH3_SW=0;   }
 485   3                if(nrf.rx[2]&0x10)  { recvSet.CH4_SW=1;   }
C51 COMPILER V9.59.0.0   APP                                                               01/09/2022 02:19:05 PAGE 9   

 486   3                else                { recvSet.CH4_SW=0;   }
 487   3                if(nrf.rx[2]&0x08)  { recvSet.CH5_SW=1;   }
 488   3                else                { recvSet.CH5_SW=0;   }
 489   3                if(nrf.rx[2]&0x04)  { recvSet.CH6_SW=1;   }
 490   3                else                { recvSet.CH6_SW=0;   }
 491   3                if(nrf.rx[2]&0x02)  { recvSet.CH7_SW=1;   }
 492   3                else                { recvSet.CH7_SW=0;   }
 493   3                if(nrf.rx[2]&0x01)  { recvSet.CH8_SW=1;   }
 494   3                else                { recvSet.CH8_SW=0;   }
 495   3      
 496   3                recv.bModeChange = 1;
 497   3                timer_startOnce(TIMER_DATA_SAVE, 1000); // save data 1000ms later
 498   3              }
 499   2              else if(nrf.rx[0]==0xa0 || nrf.rx[0]==0xa1)
 500   2              {
 501   3                buff[0]=nrf.rx[1];
 502   3                buff[0]<<=2;
 503   3                buff[0]+=nrf.rx[2]>>6;
 504   3                buff[1]=nrf.rx[2]&0x3f;
 505   3                buff[1]<<=4;
 506   3                buff[1]+=nrf.rx[3]>>4;
 507   3                buff[2]=nrf.rx[3]&0x0f;
 508   3                buff[2]<<=6;
 509   3                buff[2]+=nrf.rx[4]>>2;
 510   3                buff[3]=nrf.rx[4]&0x03;
 511   3                buff[3]<<=8;
 512   3                buff[3]+=nrf.rx[5];
 513   3      
 514   3                buff[4]=nrf.rx[6];
 515   3                buff[4]<<=2;
 516   3                buff[4]+=nrf.rx[7]>>6;
 517   3                buff[5]=nrf.rx[7]&0x3f;
 518   3                buff[5]<<=4;
 519   3                buff[5]+=nrf.rx[8]>>4;
 520   3                buff[6]=nrf.rx[8]&0x0f;
 521   3                buff[6]<<=6;
 522   3                buff[6]+=nrf.rx[9]>>2;
 523   3                buff[7]=nrf.rx[9]&0x03;
 524   3                buff[7]<<=8;
 525   3                buff[7]+=nrf.rx[10];
 526   3      
 527   3                if(nrf.rx[0]==0xa0)
 528   3                {
 529   4                  for(i=0; i<8; i++)
 530   4                  {
 531   5                    recvSet.out_control_data[i]=buff[i];
 532   5                  }
 533   4      
 534   4                  timer_startOnce(TIMER_DATA_SAVE, 1000); // save data 1000ms later
 535   4                }
 536   3                else  // nrf.rx[0]==0xa1
 537   3                {
 538   4                  for(i=0; i<8; i++)
 539   4                  {
 540   5                    DATA_mutex_get();   // 防止中断程序输出错误数据
 541   5                    recv.CH_data[i]=buff[i];
 542   5                    DATA_mutex_release();
 543   5                  }
 544   4                  SBUS_data_push();
 545   4                }
 546   3            }
 547   2              
C51 COMPILER V9.59.0.0   APP                                                               01/09/2022 02:19:05 PAGE 10  

 548   2            recv.stateNRF = STATE_NRF_RX;
 549   2            break;
 550   2          default:
 551   2            //NRF_mode_rx();
 552   2            recv.stateNRF = STATE_NRF_RX;
 553   2            break;
 554   2          }
 555   1      }
 556          
 557          /******************************************************************************/
 558          /*-DO NOT ADD YOUR CODE AFTER HERE!-*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\-WIDTH: 80-*/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2379    ----
   CONSTANT SIZE    =    256    ----
   XDATA SIZE       =     65    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     66      48
   IDATA SIZE       =     63    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
