C51 COMPILER V9.59.0.0   LOLI3_RECV_ISR_STC                                                12/13/2023 00:12:42 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE LOLI3_RECV_ISR_STC
OBJECT MODULE PLACED IN .\Objects\loli3_recv_isr_stc.obj
COMPILER INVOKED BY: C:\bin\Keil_v5\C51\BIN\C51.EXE ..\port\loli3_recv_isr_stc.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\port
                    -;..\src) DEBUG OBJECTEXTEND PRINT(.\Listings\loli3_recv_isr_stc.lst) TABS(2) OBJECT(.\Objects\loli3_recv_isr_stc.obj)

line level    source

   1          /*
   2          ********************************************************************************
   3          *                             ---ofme---
   4          *           Copyleft (c) 2021-2023, å¾®é£Žå±±è°· / ofourme@163.com
   5          *           License: LGPL
   6          *
   7          *   LOLI3_RECV_ISR_STC.C-V1.0.0 (2023.Oct.25th)
   8          *   ç¡¬ä»¶å›ºå®šè¿è¡Œé¢‘çŽ‡ï¼š12MHz
   9          *
  10          ********************************************************************************
  11          */
  12          
  13          #define __LOLI3_RECV_ISR_STC_C__
  14          
  15          /*-DO NOT ADD YOUR CODE BEFORE HERE!-*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\-WIDTH: 80-*/
  16          /******************************************************************************/
  17          
  18          #include "loli3_recv.h"
  19          
  20          /*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
  21          // ä»¥ä¸‹å˜é‡åœ¨loli3_recv_sysä¸­å®šä¹‰ï¼Œä»…åœ¨loli3_recv_sysä¸Žloli3_recv_isrä¸­ä½¿ç”¨ã€‚
  22          // å£°æ˜Žç±»åž‹åŠ¡å¿…æ³¨æ„ä¸Žloli3_recv_sysä¿æŒä¸€è‡´ã€‚
  23          
  24          extern idata volatile u32 _sys_ms;        // å½“å‰mså€¼
  25          extern idata volatile u16 _sys_us_target; // ä¸­æ–­å‘ç”Ÿç›®æ ‡uså€¼
  26          
  27          /*////////////////////////////////////////////////////////////////////////////*/
  28          // ä¸­æ–­å‡½æ•°
  29          // æ³¨æ„äº‹é¡¹1ï¼šä¸­æ–­å‡½æ•°ä¸­è°ƒç”¨å‡½æ•°çš„å¯é‡å…¥é—®é¢˜éœ€å…³æ³¨ã€‚
  30          // æ³¨æ„äº‹é¡¹2ï¼šå¦‚æžœä½¿ç”¨â€œusing 1â€â€œusing 2â€ç­‰ï¼Œèƒ½å¤Ÿåœ¨ä¸åŒä¸­æ–­ä¸­ä½¿ç”¨ä¸åŒå¯„å­˜å
             -™¨ç»„ï¼Œæå‡å“åº”é€Ÿåº¦â€¦â€¦
  31          //            ä½†è¦æ³¨æ„ä¸­æ–­ä¸­è°ƒç”¨å‡½æ•°çš„æ‰€ä½¿ç”¨çš„å¯„å­˜å™¨åœ°å€çš„æ­£ç¡®æ€§ã€‚æŽ¨èä½¿ç”¨#pragma 
             -NOAREGS/#pragma AREGSï¼Œä½¿ç”¨ç›¸å¯¹å¯„å­˜å™¨å¯»å€ã€‚
  32          //            æˆ–è€…ï¼Œæ˜¯å¦å¯ä»¥ä½¿ç”¨å†…è”å‡½æ•°æ¥é¿å…è¿™ä¸ªé—®é¢˜ï¼Ÿ
  33          /*////////////////////////////////////////////////////////////////////////////*/
  34          
  35          #if STC_15W408AS
  36          // sys tick per ms  // PCAæ¨¡å—0æ¯1msä¸­æ–­ä¸€æ¬¡
  37          void isr_tick_PCA() interrupt 7
  38          {
  39   1        CCF0 = 0; //æ¸…é™¤ä¸­æ–­æ ‡å¿—
  40   1        _sys_us_target += 1000;
  41   1        _sys_ms ++;
  42   1        CCAP0L = _sys_us_target;
  43   1        CCAP0H = _sys_us_target >> 8;
  44   1      
  45   1        timer_tick();
  46   1      }
  47          
  48          #elif STC_8H
              
              void isr_tick_T1() interrupt 3
              {
                _sys_ms ++;
C51 COMPILER V9.59.0.0   LOLI3_RECV_ISR_STC                                                12/13/2023 00:12:42 PAGE 2   

                _sys_us_target += 1000; // åœ¨STC8Hçš„å®žçŽ°ä¸­ï¼Œç”¨äºŽç¼“å­˜usè®¡æ•°
              
                timer_tick();
              }
              
              #endif
  59          
  60          /*////////////////////////////////////////////////////////////////////////////*/
  61          // ä»¥ä¸‹æ—¶é—´æŒ‰å®šæ—¶å™¨å·¥ä½œäºŽ12Tæ¨¡å¼@12MHzé¢‘çŽ‡è®¡ç®—
  62          #define TIMER_DELAY_11MS    (0x10000-FOSC/12/1000000*11000)
  63          #define TIMER_DELAY_10MS    (0x10000-FOSC/12/1000000*10000)
  64          #define TIMER_DELAY_120US   (0x10000-FOSC/12/1000000*120)
  65          #define TIMER_DELAY_400US   (0x10000-FOSC/12/1000000*400)
  66          
  67          void isr_output_T0()interrupt 1 //using 1
  68          {
  69   1      /*
  70   1        é€šé“CHnè¾“å‡ºä¸­æ–­å‡½æ•°ï¼Œä½¿ç”¨å®šæ—¶å™¨0ä¸­æ–­ç”¨äºŽé©±åŠ¨ä¿¡å·è¾“å‡ºï¼Œè®¾ç½®é«˜ä¼˜å…ˆçº§ä¸­æ–­å
             -¯æå‡è¾“å‡ºæ³¢å½¢æ—¶åºå‡†ç¡®æ€§
  71   1        C51ä¸­æ–­å‡½æ•°æ³¨æ„äº‹é¡¹ï¼šæ³¨æ„hw_pwm_set()å’ŒUART_pushByte()çš„é‡å…¥é—®é¢˜å’Œusingè°ƒç”¨å‡½æ•°é—®é
             -¢˜ï¼ï¼ï¼
  72   1      */
  73   1      /*
  74   1        STCå®šæ—¶å™¨æ¨¡å¼0(16ä½è‡ªåŠ¨é‡è£…è½½æ¨¡å¼): 
  75   1          å½“å®šæ—¶å™¨è¿è¡Œæ—¶ï¼Œå¯¹THn,TLnå†™å…¥å†…å®¹å®žé™…ä¸Šæ˜¯å†™å…¥éšè—çš„å¯„å­˜å™¨RL_THnï¼ŒRL_TLnä¸­ã€‚
  76   1          å®šæ—¶å™¨æº¢å‡ºæ—¶ä¼šè‡ªåŠ¨å°†[RL_THn,RL_TLn]çš„å†…å®¹é‡æ–°è£…å…¥[THn,TLn]ã€‚
  77   1          æ—¢å½“å‰ä¸­æ–­å“åº”ä¸­è®¾ç½®çš„å®šæ—¶æ—¶é—´ï¼Œæ˜¯ä¸‹ä¸€ä¸­æ–­å“åº”ç›¸å…³æ“ä½œçš„æŒç»­æ—¶é—´ã€‚
  78   1      */
  79   1      /*
  80   1        åŽŸç¨‹åºå­˜åœ¨çš„é—®é¢˜ï¼š
  81   1          ä¸­æ–­ç¨‹åºå¯¹è¾“å‡ºæ¨¡å¼åˆ‡æ¢æ²¡æœ‰è¿›è¡Œå¤„ç†ï¼Œä¸å¯é¿å…çš„ä¼šè¾“å‡ºä¸€å°æ®µé”™è¯¯æ•°æ®ã€‚
  82   1          å…·ä½“æ¥è¯´å°±æ˜¯: åˆ‡æ¢åˆ°ä¸åŒè¾“å‡ºæ¨¡å¼ï¼ˆSBUS/PPM/èˆµé‡ï¼‰æ—¶ï¼Œå…·ä½“é˜¶æ®µæ˜¯ä¸ç¡®å®šçš„ï¼Œ
             -è¯¥é˜¶æ®µçš„æŒç»­æ—¶é—´ä¹Ÿæ˜¯ä¸ç¡®å®šçš„ã€‚
  83   1      */
  84   1        
  85   1        static u8 step = 0; // è¾“å‡ºçŠ¶æ€ // å½“SBUSï¼Œsetp==25
  86   1        static u8 T_h=0,T_l=0;// å®šæ—¶å™¨è£…è½½å€¼æš‚å­˜
  87   1      
  88   1        u16 temp=0;
  89   1        static u16 temp0=0;
  90   1        
  91   1      //----------------------------------------------------------------------------//
  92   1      /*
  93   1        SBUSæ³¢ç‰¹çŽ‡100Kï¼Œæ¯ä½10us*æ¯å­—èŠ‚æ•°æ®12ä½ï¼ˆ1èµ·å§‹+8æ•°æ®+1å¶æ ¡æ ¸+2åœæ­¢ï¼‰=120us/å­—èŠ‚
  94   1        SBUSæ¯å¸§æ•°æ®25å­—èŠ‚ï¼Œä½Žé€Ÿæ¨¡å¼æ¯å¸§é—´éš”14msï¼ˆ120us*25+11msï¼‰ï¼Œé«˜é€Ÿæ¨¡å¼æ¯å¸§é—´éš”7msï
             -¼ˆ120us*25+4msï¼‰
  95   1      */
  96   1      /*
  97   1        åŽŸç¨‹åºSBUSè¿™ä¸€æ®µå†™çš„å¾ˆç®€æ´ç²¾å‡†ï¼Œå°±æ˜¯ä¸æ˜“ç†è§£ã€‚ä¼ªä»£ç è§£è¯»å¦‚ä¸‹ï¼š
  98   1          PIN_SBUS=1;
  99   1          if(t_sbus>24) { t_sbus=0; }
 100   1          else          { PUTCH(sbus_data[t_sbus]); t_sbus++; }
 101   1          if(t_sbus==25){ TIMER_DELAY_10MS  } // éµç…§SBUSä½Žé€Ÿæ¨¡å¼åè®®ï¼Œæ­¤å¤„å®žé™…åº”ä¸ºTIMER_DELAY_11MS
 102   1          else          { TIMER_DELAY_120US }
 103   1      
 104   1          t_sbusèŒƒå›´[0-25]å¯¹åº”26ä¸ªé˜¶æ®µï¼Œå…¶ä¸­[0-24]åŒæ—¶å¯¹åº” sbusè¾“å‡ºçš„25å­—èŠ‚ï¼Œ[25]å¯¹åº”å¸§é—´æ
             -—¶é—´é—´éš”(11MS);
 105   1          [0-25]é˜¶æ®µè®¾ç½®çš„T0æ¨¡å¼0æ—¶é—´ï¼Œå¯¹åº”ä¸‹ä¸€é˜¶æ®µ[1-25,0]çš„å»¶æ—¶ï¼›
 106   1          ä½†çŠ¶æ€å·²ç»æå‰è½¬ç§»ï¼ˆt_sbus++æˆ–t_sbus=0ï¼‰ï¼Œæ•…æ­¤æ—¶æ•°æ®t_sbuså®žé™…æŒ‡ç¤ºçš„æ˜¯ä¸‹ä¸€é˜¶æ
             -®µï¼›
 107   1          æ—¢åœ¨t_sbus==25é˜¶æ®µè®¾ç½®çš„é—´éš”æ—¶é—´ï¼Œå®žé™…æ˜¯åœ¨ç¬¬24é˜¶æ®µå·²ç»è®¾ç½®å¥½ï¼Œä¸”å°†åœ¨ç¬¬25é˜¶
             -æ®µç”Ÿæ•ˆã€‚
C51 COMPILER V9.59.0.0   LOLI3_RECV_ISR_STC                                                12/13/2023 00:12:42 PAGE 3   

 108   1      */
 109   1        if(recv.stateOUTPUT==STATE_OUTPUT_SBUS) // SBUS
 110   1        {
 111   2          //if(reset) { reset=0;  step=25;  } // è·³è½¬åˆ°è¾“å‡ºSBUS[0]çš„å‰ä¸€é˜¶æ®µä»¥è®¾ç½®SBUS[0]æŒç»­æ—¶é—´
 112   2          PIN_SBUS_SET();             // å¼ºåˆ¶å°†ä¸²å£è¾“å‡ºå£è®¾ç½®ä¸ºç©ºé—²çŠ¶æ€ï¼Œæ¸…é™¤è½¯ä»¶æ“ä½œç«¯å£å¯¼è‡´ç
             -š„é”™è¯¯ã€‚
 113   2          if(step>=25)  { step=0; } // æ­¤çŠ¶æ€æ— æ“ä½œï¼Œä½Žé€Ÿæ¨¡å¼æ—¶å»¶æ—¶11ms
 114   2          else                        // æ­¤çŠ¶æ€è¾“å‡º1å­—èŠ‚æ•°æ®ï¼ŒæŒç»­æ—¶é—´120us
 115   2          {
 116   3      #ifndef SBUS_DEBUG
 117   3      #if 0
                    UART_pushByte(recv.SBUS_tx[step]);  // æ˜¯å¦å­˜åœ¨é‡å…¥/å¯„å­˜å™¨ç»„ä¸ä¸€è‡´é—®é¢˜ï¼Ÿ
              #else
 120   3            if(TI)TI=0;
 121   3            ACC=recv.SBUS_tx[step];
 122   3            TB8=P;
 123   3            SBUF=ACC;
 124   3      #endif
 125   3            step++;
 126   3      #endif
 127   3          }
 128   2      
 129   2          if(step>=25)  { TL0=TIMER_DELAY_11MS; TH0=TIMER_DELAY_11MS>>8;  }
 130   2          else          { TL0=TIMER_DELAY_120US;TH0=TIMER_DELAY_120US>>8; }
 131   2      
 132   2          if(recv.isOutputChanged && step==0)
 133   2          {
 134   3            recv.isOutputChanged = 0;
 135   3            if(recvSet.PPM)           { recv.stateOUTPUT=STATE_OUTPUT_PPM;   step=0;}
 136   3            else if(recvSet.SBUS==0)  { recv.stateOUTPUT=STATE_OUTPUT_SERVO; step=0;}
 137   3          }
 138   2        }
 139   1      //----------------------------------------------------------------------------//
 140   1        else if(recv.stateOUTPUT==STATE_OUTPUT_PPM) // PPM
 141   1        {
 142   2          //ä»ŽPPMç«¯å£è¾“å‡º8é€šé“æ•°æ®ï¼ŒPPMä¿¡å·æ€»å‘¨æœŸ20ms
 143   2          //æ¯é€šé“å›ºå®š0.4msä½Žç”µå¹³å¼€å§‹ï¼Œ0.6åˆ°1.6msï¼ˆå®žé™…1.623msï¼‰é«˜ç”µå¹³ç»“æŸ
 144   2          #define PPM_CH_PULSE()  do{CH1=0;TL0=T_l;TH0=T_h;}while(0)
 145   2          #define PPM_CH_WIDTH()  do{CH1=1;TL0=TIMER_DELAY_400US; TH0=TIMER_DELAY_400US>>8;}while(0)
 146   2          //PPMå°¾éƒ¨ç›´æŽ¥å»¶æ—¶10msä»¥èŠ‚çº¦è®¡ç®—æ—¶é—´ï¼Œå‘¨æœŸä¸ä¿è¯50Hz    
 147   2          #define PPM_CH_END()    do{CH1=0;TL0=TIMER_DELAY_10MS;  TH0=TIMER_DELAY_10MS>>8;}while(0)
 148   2          #define PPM_CH_IDLE()   PPM_CH_WIDTH()
 149   2          #define PPM_CH_PULSE_TIME_GET(ch) do{temp=0x10000-600-recv.CH_data[ch]; T_l=temp;T_h=temp>>8;}while(0)
 150   2      
 151   2          switch(step)
 152   2          {
 153   3            case 0: PPM_CH_IDLE();
 154   3                    PPM_CH_PULSE_TIME_GET(0);
 155   3                    break;
 156   3            case 1: PPM_CH_PULSE();break;
 157   3            case 2: PPM_CH_WIDTH();
 158   3                    PPM_CH_PULSE_TIME_GET(1);
 159   3                    break;
 160   3            case 3: PPM_CH_PULSE();break;
 161   3            case 4: PPM_CH_WIDTH();
 162   3                    PPM_CH_PULSE_TIME_GET(2);
 163   3                    break;
 164   3            case 5: PPM_CH_PULSE();break;
 165   3            case 6: PPM_CH_WIDTH();
 166   3                    PPM_CH_PULSE_TIME_GET(3);
 167   3                    break;
 168   3            case 7: PPM_CH_PULSE();break;
C51 COMPILER V9.59.0.0   LOLI3_RECV_ISR_STC                                                12/13/2023 00:12:42 PAGE 4   

 169   3            case 8: PPM_CH_WIDTH();
 170   3                    PPM_CH_PULSE_TIME_GET(4);
 171   3                    break;
 172   3            case  9:PPM_CH_PULSE();break;
 173   3            case 10:PPM_CH_WIDTH();
 174   3                    PPM_CH_PULSE_TIME_GET(5);
 175   3                    break;
 176   3            case 11:PPM_CH_PULSE();break;
 177   3            case 12:PPM_CH_WIDTH();
 178   3                    PPM_CH_PULSE_TIME_GET(6);
 179   3                    break;
 180   3            case 13:PPM_CH_PULSE();break;
 181   3            case 14:PPM_CH_WIDTH();
 182   3                    PPM_CH_PULSE_TIME_GET(7);
 183   3                    break;
 184   3            case 15:PPM_CH_PULSE();break;
 185   3            case 16:PPM_CH_WIDTH();
 186   3                    break;
 187   3            case 17:PPM_CH_END();  break;
 188   3            default:break;
 189   3          }
 190   2      
 191   2          if(recv.isOutputChanged && step==0)
 192   2          {
 193   3            recv.isOutputChanged = 0;
 194   3            if(recvSet.SBUS)        { recv.stateOUTPUT=STATE_OUTPUT_SBUS;  step=25;}
 195   3            else if(recvSet.PPM==0) { recv.stateOUTPUT=STATE_OUTPUT_SERVO; step=0;}
 196   3          }
 197   2      
 198   2          step++; if(step>17) step=0;
 199   2        }
 200   1      //----------------------------------------------------------------------------//
 201   1        else
 202   1        { // èˆµé‡è¾“å‡ºå‘¨æœŸ20msï¼Œ8é€šé“å¹³åˆ†åˆ™æ¯é€šé“è€—æ—¶2.5ms
 203   2          // PULSE_TIME+INTERVER_TIME==2.5msï¼ŒPULSE_TIME=0x10000-temp0, INTERVER_TIME=0x10000-temp
 204   2          // -> temp=0x10000-INTERVER_TIME=0x10000+PULSE_TIME-2500=0x10000-2500+0x10000-temp0=0x20000-2500-temp0
 205   2          // ç»è®¡ç®—ï¼Œtemp=128572-temp0ï¼Œloli3åŽŸç¨‹åºtemp=128600-temp0ä¼¼ä¹Žæœ‰é”™ï¼Ÿï¼
 206   2          #define SERVO_CH_PULSE_TIME_SET(ch) \
 207   2              do{ temp0=0x10000-813-((recv.CH_data[ch]*LOLI3_RECV_SERVO_RANGE_MUL)>>LOLI3_RECV_SERVO_RANGE_R_SHIFT) 
             -;\
 208   2                  TL0=temp0,TH0=temp0>>8;}\
 209   2              while(0)
 210   2          #define SERVO_CH_INTERVER_TIME_SET(ch)  \
 211   2              do{ temp=0x20000-2500-temp0; TL0=temp,TH0=temp>>8;}\
 212   2              while(0)
 213   2              
 214   2          switch(step)
 215   2          {
 216   3            case 0:
 217   3              if(recvSet.CH8_SW==0) CH8=0;
 218   3              SERVO_CH_PULSE_TIME_SET(0);
 219   3              break;
 220   3      
 221   3            case 1:
 222   3              if(recvSet.CH1_PWM)     hw_pwm_set(1,recv.CH_data[0]/4);
 223   3              else if(recvSet.CH1_SW){if(recv.CH_data[0]<500) CH1=0; else CH1=1;}
 224   3              else                    CH1=1;
 225   3              SERVO_CH_INTERVER_TIME_SET(0);
 226   3              break;
 227   3            case 2:
 228   3              if(recvSet.CH1_PWM==0 && recvSet.CH1_SW==0) CH1=0;
 229   3              SERVO_CH_PULSE_TIME_SET(1);
C51 COMPILER V9.59.0.0   LOLI3_RECV_ISR_STC                                                12/13/2023 00:12:42 PAGE 5   

 230   3              break;
 231   3      
 232   3            case 3:
 233   3              if(recvSet.CH2_PWM)     hw_pwm_set(2,recv.CH_data[1]/4);
 234   3              else if(recvSet.CH2_SW){if(recv.CH_data[1]<500) CH2=0; else CH2=1;}
 235   3              else                    CH2=1;
 236   3              SERVO_CH_INTERVER_TIME_SET(1);
 237   3              break;
 238   3            case 4:
 239   3              if(recvSet.CH2_PWM==0 && recvSet.CH2_SW==0) CH2=0;
 240   3              SERVO_CH_PULSE_TIME_SET(2);
 241   3              break;
 242   3      
 243   3            case 5:
 244   3              if(recvSet.CH3_SW) {if(recv.CH_data[2]<500) CH3=0; else CH3=1;}
 245   3              else                CH3=1;
 246   3              SERVO_CH_INTERVER_TIME_SET(2);
 247   3              break;
 248   3            case 6:
 249   3              if(recvSet.CH3_SW==0) CH3=0;
 250   3              SERVO_CH_PULSE_TIME_SET(3);
 251   3              break;
 252   3      
 253   3            case 7:
 254   3              if(recvSet.CH4_SW) {if(recv.CH_data[3]<500) CH4=0; else CH4=1;}
 255   3              else                CH4=1;
 256   3              SERVO_CH_INTERVER_TIME_SET(3);
 257   3              break;
 258   3            case 8:
 259   3              if(recvSet.CH4_SW==0) CH4=0;
 260   3              SERVO_CH_PULSE_TIME_SET(4);
 261   3              break;
 262   3      
 263   3            case 9:
 264   3              if(recvSet.CH5_SW) {if(recv.CH_data[4]<500) CH5=0; else CH5=1;}
 265   3              else                CH5=1;
 266   3              SERVO_CH_INTERVER_TIME_SET(4);
 267   3              break;
 268   3            case 10:
 269   3              if(recvSet.CH5_SW==0) CH5=0;
 270   3              SERVO_CH_PULSE_TIME_SET(5);
 271   3              break;
 272   3      
 273   3            case 11:
 274   3              if(recvSet.CH6_SW) {if(recv.CH_data[5]<500) CH6=0; else CH6=1;}
 275   3              else                CH6=1;
 276   3              SERVO_CH_INTERVER_TIME_SET(5);
 277   3              break;
 278   3            case 12:
 279   3              if(recvSet.CH6_SW==0) CH6=0;
 280   3              SERVO_CH_PULSE_TIME_SET(6);
 281   3              break;
 282   3      
 283   3            case 13:
 284   3              // ç¡¬ä»¶ä¸²å£å¯¹åº”é€šé“
 285   3              #ifndef SBUS_DEBUG
 286   3              if(recvSet.CH7_SW) {if(recv.CH_data[6]<500) CH7=0; else CH7=1;}
 287   3              else                CH7=1;
 288   3              #endif
 289   3              SERVO_CH_INTERVER_TIME_SET(6);
 290   3              break;
 291   3            case 14:
C51 COMPILER V9.59.0.0   LOLI3_RECV_ISR_STC                                                12/13/2023 00:12:42 PAGE 6   

 292   3              #ifndef SBUS_DEBUG
 293   3              if(recvSet.CH7_SW==0) CH7=0;
 294   3              #endif
 295   3              SERVO_CH_PULSE_TIME_SET(7);
 296   3              break;
 297   3      
 298   3            case 15:
 299   3              if(recvSet.CH8_SW) {if(recv.CH_data[7]<500) CH8=0; else CH8=1;}
 300   3              else                CH8=1;
 301   3              SERVO_CH_INTERVER_TIME_SET(7);
 302   3              break;
 303   3            default:break;
 304   3          }
 305   2      
 306   2          if(recv.isOutputChanged && step==0)
 307   2          {
 308   3            recv.isOutputChanged = 0;
 309   3            if(recvSet.SBUS)      { recv.stateOUTPUT=STATE_OUTPUT_SBUS; step=25;}
 310   3            else if(recvSet.PPM)  { recv.stateOUTPUT=STATE_OUTPUT_PPM; step=0;}
 311   3          }
 312   2      
 313   2          step++; if(step>15) step=0;
 314   2        }
 315   1      }
 316          
 317          /******************************************************************************/
 318          /*-DO NOT ADD YOUR CODE AFTER HERE!-*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\-WIDTH: 80-*/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1337    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      5       2
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
