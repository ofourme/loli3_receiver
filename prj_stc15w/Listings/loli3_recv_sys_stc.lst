C51 COMPILER V9.59.0.0   LOLI3_RECV_SYS_STC                                                12/13/2023 00:12:42 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE LOLI3_RECV_SYS_STC
OBJECT MODULE PLACED IN .\Objects\loli3_recv_sys_stc.obj
COMPILER INVOKED BY: C:\bin\Keil_v5\C51\BIN\C51.EXE ..\port\loli3_recv_sys_stc.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\port
                    -;..\src) DEBUG OBJECTEXTEND PRINT(.\Listings\loli3_recv_sys_stc.lst) TABS(2) OBJECT(.\Objects\loli3_recv_sys_stc.obj)

line level    source

   1          /*
   2          ********************************************************************************
   3          *                             ---ofme---
   4          *           Copyleft (c) 2021-2023, ÂæÆÈ£éÂ±±Ë∞∑ / ofourme@163.com
   5          *           License: LGPL
   6          *
   7          *   LOLI3_RECV_SYS_STC.C-V1.0.0 (2023.Oct.25th)
   8          *   Á®ãÂ∫èÂåπÈÖçÁ°¨‰ª∂ÔºöSTC15W / STC8H
   9          *   Á°¨‰ª∂Âõ∫ÂÆöËøêË°åÈ¢ëÁéáÔºö12MHz
  10          *
  11          ********************************************************************************
  12          */
  13          
  14          #define __LOLI3_RECV_SYS_STC_C__
  15          
  16          /*-DO NOT ADD YOUR CODE BEFORE HERE!-*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\-WIDTH: 80-*/
  17          /******************************************************************************/
  18          
  19          #include "loli3_recv_port.h"
  20          
  21          /*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
  22          
  23          idata volatile u32 _sys_ms;         // ÂΩìÂâçmsÂÄº
  24          idata volatile u16 _sys_us_target;  // ‰∏≠Êñ≠ÂèëÁîüÁõÆÊ†áusÂÄº
  25          
  26          #if defined( SBUS_BPS_115200 )
                #define UART_BPS  UART_BPS_115200
              #elif defined ( SBUS_BPS_9600 )
                #define UART_BPS  UART_BPS_9600
              #else
  31            #define UART_BPS  UART_BPS_100K
  32          #endif
  33          
  34          /*////////////////////////////////////////////////////////////////////////////*/
  35          //Âª∂Êó∂ÂáΩÊï∞Ôºå‰ªÖ‰æùËµñÁ≥ªÁªüÊó∂ÈíüÔºåÊó†ÈúÄÂÖ∂‰ªñÊ®°ÂùóÂàùÂßãÂåñ
  36          void hw_delay_1ms()   //@12.000MHz
  37          {
  38   1        unsigned char i, j;
  39   1        i = 12;
  40   1        j = 168;
  41   1        do
  42   1        {
  43   2          while (--j);
  44   2        } while (--i);
  45   1      }
  46          
  47          void hw_delay_ms(u8 ms)
  48          {
  49   1        while(ms--) hw_delay_1ms();
  50   1      }
  51          
  52          /*////////////////////////////////////////////////////////////////////////////*/
  53          void hw_io_chs_init()
  54          {
C51 COMPILER V9.59.0.0   LOLI3_RECV_SYS_STC                                                12/13/2023 00:12:42 PAGE 2   

  55   1      #if STC_15W408AS
  56   1        //stc15w IOÂè£ÈªòËÆ§ÂáÜÂèåÂêëÂè£Ê®°ÂºèÔºåÊó†ÈúÄ‰øÆÊîπPxM0ÂíåPxM1
  57   1        CH1=0;
  58   1        CH2=0;
  59   1        CH3=0;
  60   1        CH4=0;
  61   1        CH5=0;
  62   1        CH6=0;
  63   1        CH7=0;
  64   1        CH8=0;
  65   1      #elif STC_8H
                // P1+P3+P5.4 Áî±È´òÈòªÊîπ‰∏∫ÂèåÂêëÊ®°Âºè
                P1M0 = 0x00;
                P1M1 = 0x00;
                P3M0 = 0x00;
                P3M1 = 0x00;
                P5M0 = 0xf7;
                P5M1 = 0xf7;
                
                CH1=0;
                CH2=0;
                CH3=0;
                CH4=0;
                CH5=0;
                CH6=0;
                CH7=0;
                CH8=0;
              
              #endif
  84   1      }
  85          
  86          void hw_io_cho_init()
  87          {
  88   1      // CH5 ËÆæ‰∏∫Êé®ÊåΩËæìÂá∫Ê®°Âºè
  89   1      #if defined   PIN_CH_OUT_P31
                P3M0=1<<1;
              #elif defined PIN_CH_OUT_P33
  92   1        P3M0=1<<3;
  93   1      #elif defined PIN_CH_OUT_P37
                P3M0=1<<7;
              #else
                  #err "CH out pin not set OUTPUT."
              #endif
  98   1      }
  99          void hw_io_cho_clr()
 100          {
 101   1      #if defined PIN_CH_OUT_P31
                P31 = 0;
              #elif defined PIN_CH_OUT_P33
 104   1        P33 = 0;
 105   1      #elif defined PIN_CH_OUT_P37
                P37 = 0;
              #else
                #err "PIN_CH_OUT not CLR."
              #endif
 110   1      }
 111          void hw_io_cho_set()
 112          {
 113   1      #if defined PIN_CH_OUT_P31
                P31 = 1;
              #elif defined PIN_CH_OUT_P33
 116   1        P33 = 1;
C51 COMPILER V9.59.0.0   LOLI3_RECV_SYS_STC                                                12/13/2023 00:12:42 PAGE 3   

 117   1      #elif defined PIN_CH_OUT_P37
                P37 = 1;
              #else
                #err "PIN_CH_OUT not SET."
              #endif
 122   1      }
 123          
 124          void hw_io_chi_init()
 125          {
 126   1      //  CH6=1;  // ÈªòËÆ§ÂáÜÂèåÂêëÂè£Ê®°ÂºèÔºåËÆæÁΩÆ1Âº±‰∏äÊãâÔºå‰∏îÂÖÅËÆ∏Â§ñÈÉ®Êãâ‰ΩéÂà∞0„ÄÇ
 127   1      #if defined PIN_CH_IN_P32
 128   1        P32 = 1;
 129   1      #elif defined PIN_CH_IN_P36
                P36 = 1;
              #else
                #err "PIN_CH_IN not set INPUT."
              #endif
 134   1      }
 135          
 136          u8 hw_io_chi_get()
 137          {
 138   1      #if defined PIN_CH_IN_P32
 139   1        return (u8)(P32);
 140   1      #elif defined PIN_CH_IN_P36
                return (u8)(P36);
              #else
                #err "PIN_CH_IN not GET."
              #endif
 145   1      }
 146          
 147          void hw_io_chs_pushpull()
 148          {
 149   1        CH1=0;
 150   1        CH2=0;
 151   1        CH3=0;
 152   1        CH4=0;
 153   1        CH5=0;
 154   1        CH6=0;
 155   1      //stc51 uart Âè£ËæìÂá∫0Â∞ÜÂØºËá¥‰∏≤Âè£Êó†Ê≥ïËæìÂá∫//CH7=0;//PIN_SBUS=1;
 156   1        CH8=0;
 157   1      
 158   1        //Êé•‰∏ãÊù•ÂèØÂ∞ÜÈÄöÈÅìËæìÂá∫IOÂè£ÈÖçÁΩÆ‰∏∫Êé®ÊåΩÊ®°ÂºèÔºå‰øùËØÅÊ≠£Â∏∏È©±Âä®ÁîµË∞É‰∏éËàµÊú∫
 159   1        //‰∏çÈÖçÁΩÆÊé®ÊåΩ‰ºº‰πé‰πüÂèØ‰ª•ÔºüÈÖçÁΩÆÊé®ÊåΩ‰ºöÂê¶ÂΩ±Âìç‰∏≤Âè£‰º†ËæìÊï∞ÊçÆÔºü
 160   1        P3M0=0xFF;
 161   1      }
 162          
 163          /*////////////////////////////////////////////////////////////////////////////*/
 164          // ‰∏≤Âè£ÈÄöËÆØÔºå‰ΩøÁî®ÂÆöÊó∂Âô®2
 165          void hw_uart_init(u8 bps)
 166          {
 167   1        SCON = 0xD0;    //9‰ΩçÊï∞ÊçÆ,ÂèØÂèòÊ≥¢ÁâπÁéá
 168   1        AUXR |= 0x01;   //‰∏≤Âè£1ÈÄâÊã©ÂÆöÊó∂Âô®2‰∏∫Ê≥¢ÁâπÁéáÂèëÁîüÂô®
 169   1        AUXR |= 0x04;   //ÂÆöÊó∂Âô®2Êó∂Èíü‰∏∫Fosc,Âç≥1T
 170   1      
 171   1        if(bps==UART_BPS_9600)  //9600bps@12.000MHz
 172   1        {
 173   2          T2L = 0xC7;
 174   2          T2H = 0xFE;
 175   2        }
 176   1        else if(bps==UART_BPS_115200) //115200bps@12.000MHz
 177   1        {
 178   2          T2L = 0xE6;   //ËÆæÁΩÆÂÆöÊó∂ÂàùÂßãÂÄº
C51 COMPILER V9.59.0.0   LOLI3_RECV_SYS_STC                                                12/13/2023 00:12:42 PAGE 4   

 179   2          T2H = 0xFF;   //ËÆæÁΩÆÂÆöÊó∂ÂàùÂßãÂÄº
 180   2        }
 181   1        else      //100000bps@12.000MHz
 182   1        {
 183   2          T2L = 0xE2;   //ËÆæÂÆöÂÆöÊó∂ÂàùÂÄº
 184   2          T2H = 0xFF;   //ËÆæÂÆöÂÆöÊó∂ÂàùÂÄº
 185   2        }
 186   1      
 187   1        PIN_SBUS_SET();
 188   1        AUXR |= 0x10;   //ÂÆöÊó∂Âô®2ÂºÄÂßãËÆ°Êó∂
 189   1      }
 190          
 191          void UART_pushByte(char c)
 192          {
 193   1          if(TI)TI=0;
 194   1          ACC=c;
 195   1          TB8=P;
 196   1          SBUF=ACC;
 197   1      }
 198          
 199          void hw_uart_puts(const char* str)
 200          {
 201   1        while(*str)
 202   1        {
 203   2          UART_pushByte(*str++);
 204   2          while(!TI); // bugfix(20211220): Â∞ÜÊ≠§Âè•ÁßªÂà∞UART_pushByte()ÂêéÈù¢ÔºåÈò≤Ê≠¢Ê≠ªÂæ™ÁéØ„ÄÇÂâØ‰ΩúÁî®ÊòØÂá
             -ΩÊï∞Â§ñÈÉ®‰πãÂâç‰ΩøÁî®UART_pushByte()ÂèØËÉΩÊú™ÂèëÈÄÅÂÆåÊàêÂ∞±Ë¢´ÁªàÊ≠¢„ÄÇ
 205   2        }
 206   1        UART_pushByte('\r');
 207   1        while(!TI);
 208   1        UART_pushByte('\n');
 209   1        while(!TI);
 210   1      }
 211          
 212          /*////////////////////////////////////////////////////////////////////////////*/
 213          //ÁîµÂéãÊµãÈáèÊ®°ÂùóÔºöÊé•Êî∂Êú∫Á®ãÂ∫èÂØπADCËøîÂõûÊï∞ÊçÆÊåâ10‰ΩçÂ§ÑÁêÜÔºåÁßªÊ§ç‰∏çÂêåÁ°¨‰ª∂ÈúÄÊ≥®ÊÑè‰øùÊåÅ
             -‰∏ÄËá¥
 214          //ÁîµÂéãÊµãÈáèÂäüËÉΩÂàùÂßãÂåñ
 215          void hw_adc_init()
 216          {
 217   1        //Â∞ÜADËæìÂÖ•Âè£ËÆæÁΩÆ‰∏∫È´òÈòªËæìÂÖ•ÔºåËØ¶ËßÅSTC15ÊâãÂÜåP400Ë¶ÅÊ±Ç
 218   1      #if defined   PIN_ADC_P1X
 219   1        P1M1 |=  1<<PIN_ADC_P1X;  //8ÈÄöÈÅìÊé•Êî∂Êú∫‰ΩøÁî®P1.xÂè£ÂÅöADCËæìÂÖ•Âè£
 220   1      #else
                  #err "ADC pin not inited."
              #endif
 223   1      
 224   1      #if STC_15W408AS
 225   1        ADC_CONTR=0x80;   //ADC‰∏äÁîµ
 226   1        hw_delay_ms(2);   //Âª∂Êó∂Á≠âÂæÖADCÊ®°ÂùóÁ®≥ÂÆö
 227   1      
 228   1        P1ASF=0x00;       //‰∏çËØªÂèñP1Âè£ÔºåËÄåÊòØ‰∏ãÊ¨°ËØªÂèñÂÜÖÈÉ®ÂèÇËÄÉÁîµÂéã‰øùÂ≠òÂú®_adc_icÈáå
 229   1        ADC_CONTR=0x88;   //ÂêØÂä®ËΩ¨Êç¢
 230   1        while(ADC_CONTR&0x10==0);//Á≠âÂæÖËΩ¨Êç¢ÂÆåÊàê
 231   1      #elif STC_8H
                // ADCÊéßÂà∂ÂØÑÂ≠òÂô®ADC_CONTRÈÖçÁΩÆ‰ΩçÔºöÊâìÂºÄADËΩ¨Êç¢Âô®ÁîµÊ∫ê/ÂêØÂä®ADËΩ¨Êç¢/ËΩ¨Êç¢ÁªìÊùüÊ†áÂøó‰Ωç
                #define ADC_POWER 7
                #define ADC_START 6
                #define ADC_FLAG  5
                ADCTIM = 0x3F;
                ADC_CONTR = (1<<ADC_POWER | 0<<ADC_START | 0<<ADC_FLAG);
                hw_delay_ms(2);   //Âª∂Êó∂Á≠âÂæÖADCÊ®°ÂùóÁ®≥ÂÆö
C51 COMPILER V9.59.0.0   LOLI3_RECV_SYS_STC                                                12/13/2023 00:12:42 PAGE 5   

              
                ADC_CONTR = (1<<ADC_POWER | 1<<ADC_START | 0<<ADC_FLAG)|15; // ËØªÂèñÂÜÖÈÉ®ÂèÇËÄÉÁîµÂéã‰øùÂ≠òÂú®_adc_icÈá
             -å
                while (!(ADC_CONTR & (1<<ADC_FLAG))); ////Á≠âÂæÖËΩ¨Êç¢ÂÆåÊàê
              #endif
 243   1      }
 244          //ADËΩ¨Êç¢È¢ÑÂêØÂä®
 245          void hw_adc_open(u8 i)  //0ÔºöÂÜÖÈÉ®ÂèÇËÄÉÁîµÂéãÔºõ1ÔºöÂ§ñÈÉ®ÁîµÂéã
 246          {
 247   1      #if STC_15W408AS
 248   1        if(i&0x01)
 249   1        {
 250   2      #if defined   PIN_ADC_P1X
 251   2          P1ASF=0x01<<PIN_ADC_P1X;    //P1Âè£Ê®°ÊãüÂäüËÉΩÊéßÂà∂ÂØÑÂ≠òÂô®Ôºöp1.x‰Ωú‰∏∫Ê®°ÊãüÂäüËÉΩA/D‰ΩøÁî®Ôºå‰∏ãÊ¨°Ë
             -ØªÂèñÁîµÊ±†ÁîµÂéã‰øùÂ≠òÂú®_adc_battÈáå
 252   2          ADC_CONTR= 1<<7 | 0<<4 | 1<<3 | PIN_ADC_P1X<<0;   //ADCÊéßÂà∂ÂØÑÂ≠òÂô®ÔºöÊâìÂºÄADËΩ¨Êç¢Âô®ÁîµÊ∫ê/Ê∏ÖÈô§ËΩ
             -¨Êç¢ÁªìÊùüÊ†áÂøó‰Ωç/ÂêØÂä®ADËΩ¨Êç¢/p1.x‰ΩúADËæìÂÖ•
 253   2      #else
                  #err "ADC pin not P1.x"
              #endif
 256   2        }
 257   1        else
 258   1        {
 259   2          P1ASF=0x00;       //‰∏çËØªÂèñP1Âè£ÔºåËÄåÊòØ‰∏ãÊ¨°ËØªÂèñÂÜÖÈÉ®ÂèÇËÄÉÁîµÂéã‰øùÂ≠òÂú®_adc_icÈáå
 260   2          ADC_CONTR=0x88;   //ÂêØÂä®ËΩ¨Êç¢
 261   2        }
 262   1      #elif STC_8H
                if(i&0x01)
                {
              #if defined   PIN_ADC_P1X
                  ADC_CONTR = (1<<ADC_POWER | 1<<ADC_START | 0<<ADC_FLAG) | PIN_ADC_P1X ;
              #else
                  #err "ADC pin not P1.x"
              #endif
                }
                else
                {
                  ADC_CONTR = (1<<ADC_POWER | 1<<ADC_START | 0<<ADC_FLAG) | 15 ;
                }
              #endif
 276   1      }
 277          
 278          //ËØªÂèñ‰∏ä‰∏ÄÊ¨°ÂêØÂä®ADËΩ¨Êç¢Ëé∑ÂæóÁöÑÂÄº„ÄÇ
 279          //Êú¨ÂáΩÊï∞ÂÆûÁé∞Ê≤°ÊúâÂà§Êñ≠ËΩ¨Êç¢ÊòØÂê¶ÂÆåÊàêÔºå‰ΩøÁî®Êó∂ÈúÄÊ≥®ÊÑèÊó∂Èó¥Èó¥Èöî„ÄÇ
 280          u16 hw_adc_read()
 281          {
 282   1        u16 adc;
 283   1      
 284   1      #if STC_15W408AS
 285   1        // ADC_RES[7:0] & ADC_RESL[1:0] ÁªÑÊàê10‰ΩçÁªìÊûú // 20230813
 286   1        adc=ADC_RES;
 287   1        adc<<=2,adc|=ADC_RESL;
 288   1      #elif STC_8H
                adc = ((u16)ADC_RES<<2)|(ADC_RESL>>6);
              #endif  
 291   1        return adc;
 292   1      }
 293          
 294          /*////////////////////////////////////////////////////////////////////////////*/
 295          
 296          void hw_tick_init()
 297          {
C51 COMPILER V9.59.0.0   LOLI3_RECV_SYS_STC                                                12/13/2023 00:12:42 PAGE 6   

 298   1      #if STC_15W408AS
 299   1        //‰ªªÂä°ÂÆöÊó∂Âô®‰∏≠Êñ≠ÂàùÂßãÂåñÔºà‰ΩøÁî®PCAÂÆöÊó∂Âô®Ê®°Âùó0‰∏≠Êñ≠Ôºâ
 300   1        _sys_ms = 0;
 301   1        CCON =0x00;     //PCAÊéßÂà∂ÂØÑÂ≠òÂô®ÔºöÂÅúÊ≠¢PCAÂÆöÊó∂Âô®ÔºåÊ∏ÖÈô§‰∏≠Êñ≠Ê†áÂøó
 302   1        CL=0;CH=0;      //Â§ç‰ΩçPCAËÆ°Êï∞Âô®
 303   1        CMOD=0x00;      //PCAÂ∑•‰ΩúÊ®°ÂºèÂØÑÂ≠òÂô®ÔºöÁ©∫Èó≤Ê®°Âºè‰∏ãÁªßÁª≠Â∑•‰ΩúÔºåÁ≥ªÁªüÊó∂Èíü/12ÔºåËÆ°Êï∞Ê∫¢Âá∫‰∏≠
             -Êñ≠Á¶ÅÊ≠¢
 304   1        _sys_us_target = 1000;  //1 ms
 305   1        CCAP0L = _sys_us_target;
 306   1        CCAP0H = _sys_us_target >> 8;
 307   1        CCAPM0 = 0x49;  //PCAÊ®°Âùó0ÁöÑÊØîËæÉ/ÊçïËé∑ÂØÑÂ≠òÂô®ÔºöÂÖÅËÆ∏ÊØîËæÉÂô®ÂäüËÉΩÔºåÂåπÈÖçÁΩÆ‰ΩçCCONÊ†áÂøó‰ΩçC
             -CF0Ôºå‰ΩøËÉΩCCF0‰∏≠Êñ≠
 308   1      
 309   1      #elif STC_8H
                //‰ªªÂä°ÂÆöÊó∂Âô®‰∏≠Êñ≠ÂàùÂßãÂåñÔºà‰ΩøÁî®ÂÆöÊó∂Âô®1‰∏≠Êñ≠Ôºâ
                // Á≥ªÁªüËÆ°Êó∂ÂèòÈáèÂàùÂßãÂåñ
                _sys_ms = 0;
                _sys_us_target = 0; // Âú®STC8HÁöÑÂÆûÁé∞‰∏≠ÔºåÁî®‰∫éÁºìÂ≠òusËÆ°Êï∞
                //T1ËÆæÁΩÆ‰∏∫Ê®°Âºè0Ôºö16‰ΩçËá™Âä®ÈáçË£ÖÂÆöÊó∂Âô®ÔºåÂΩìÊ∫¢Âá∫Êó∂Â∞ÜRL_TH1ÂíåRL_TL1Â≠òÊîæÁöÑÂÄºËá™Âä®ÈáçË£
             -ÖÂÖ•TH1ÂíåTL1‰∏≠
                TMOD &= 0x0F; // È´ò4‰ΩçÊ∏ÖÈõ∂
                TMOD |= 0x00; // ËôöÊãüËµãÂÄºÔºåÈ´ò4‰ΩçËµãÂÄº0
                AUXR &= ~(0x40);//ÈªòËÆ§12TÊ®°Âºè
                IE=0x08; //ÂÖÅËÆ∏T1‰∏≠Êñ≠
                TH1 = (0x10000-FOSC/12/1000000*1000)>>8;
                TL1 = (0x10000-FOSC/12/1000000*1000);
              
              #endif
 323   1      }
 324          
 325          #if FUNC_MILLIS_EN
              u32 millis(void)
              {
                u32 temp;
              
              #if STC_15W408AS
                CCAPM0 = 0x48;  // bugfix(20230902): disable CCF0 interrupt, not disable T0 interrupt
                temp = _sys_ms;
                CCAPM0 = 0x49;  //enable PCA interrupt.
              #elif STC_8H
                ET1 = 0;
                temp = _sys_ms;
                ET1 = 1;
              #endif
                return temp;
              }
              #endif
 342          
 343          #if FUNC_MICROS_EN
 344          u16 micros(void)
 345          {
 346   1      #if STC_15W408AS
 347   1      
 348   1        u8 H0,H1,L;
 349   1      
 350   1        H0 = CH;  // read PCA clock time.
 351   1        L  = CL;
 352   1        H1 = CH;
 353   1        if(H1!=H0) L=0;
 354   1      
 355   1        return ((u16)H1<<8) | L;
 356   1      
C51 COMPILER V9.59.0.0   LOLI3_RECV_SYS_STC                                                12/13/2023 00:12:42 PAGE 7   

 357   1      #elif STC_8H
              
                u8 H0,H1,L;
                u16 T16, Tus;
              
                ET1 = 0;
                Tus = _sys_us_target;
                H0 = TH1; // read T1 clock time.
                L  = TL1;
                H1 = TH1;
                ET1 = 1;
              
                if(H1!=H0) L=0;
                T16 = (((u16)H1<<8)|L) - (0x10000-FOSC/12/1000000*1000);
              
                return (Tus+T16);
                
              #endif
 375   1      }
 376          #endif
 377          
 378          #if FUNC_DELAY_EN
 379          void delay(u16 i)
 380          {
 381   1        #if 1
 382   1        while(i--)
 383   1        hw_delay_1ms();
 384   1        #else
                
                #endif
 387   1      }
 388          #endif
 389          
 390          #if FUNC_DELAYMICROSECONDS_EN
              void delayMicroseconds(u16 us)
              {
                //v20220107: cur-start<us <<-->> (cur+0x10000)-start<us
                u16 start = micros();
                while(micros()-start<us);
              }
              #endif
 398          
 399          /*////////////////////////////////////////////////////////////////////////////*/
 400          //ÈÄöÈÅìËàµÈáèËæìÂá∫/pwmËæìÂá∫ÂäüËÉΩÂàùÂßãÂåñ
 401          void hw_output_init()
 402          {
 403   1      #if 1
 404   1      //ËàµÈáèËæìÂá∫ÊéßÂà∂ÂÆöÊó∂Âô®‰∏≠Êñ≠ÂàùÂßãÂåñÔºåÈ´ò‰ºòÂÖàÁ∫ßÔºà‰ΩøÁî®ÂÆöÊó∂Âô®0Ôºâ
 405   1        IP=0x02;      //T0‰∏≠Êñ≠È´ò‰ºòÂÖàÁ∫ßÔºåÂÖ∂ÂÆÉ‰Ωé‰ºòÂÖàÁ∫ß
 406   1        //T0ËÆæÁΩÆ‰∏∫Ê®°Âºè0Ôºö16‰ΩçËá™Âä®ÈáçË£ÖÂÆöÊó∂Âô®ÔºåÂΩìÊ∫¢Âá∫Êó∂Â∞ÜRL_TH0ÂíåRL_TL0Â≠òÊîæÁöÑÂÄºËá™Âä®ÈáçË£
             -ÖÂÖ•TH0ÂíåTL0‰∏≠
 407   1        TMOD &= 0xF0; //bugfix(20230812): 0x0FÊîπ‰∏∫0xF0
 408   1        TMOD |= 0x00;
 409   1        ET0 = 1; //ÂÖÅËÆ∏T0‰∏≠Êñ≠
 410   1      #endif
 411   1      
 412   1      #if STC_15W408AS
 413   1        //Á°¨‰ª∂PWMËæìÂá∫ÂäüËÉΩÂàùÂßãÂåñÔºà‰ΩøÁî®PCAÂÆöÊó∂Âô®Ê®°Âùó2/1ÁöÑ8‰ΩçpwmÂäüËÉΩÔºåPCAËæìÂÖ•Êó∂ÈíüÈ¢ëÁéá1MH
             -zÔºåpwmÈ¢ëÁéá=1MHz/256~=4kÔºâ
 414   1        P_SW1 &= ~(3<<4); //Â§ñËÆæÂäüËÉΩÂàáÊç¢ÂØÑÂ≠òÂô®1ÔºöPWMÂºïËÑöÂàáÊç¢Âà∞P3.5~P3.7
 415   1        P_SW1 |= 1<<4;
 416   1        PCA_PWM2=0x03;    //ÔºàP3.7Ôºâ8‰ΩçPWMÊ®°Âºè
C51 COMPILER V9.59.0.0   LOLI3_RECV_SYS_STC                                                12/13/2023 00:12:42 PAGE 8   

 417   1        PCA_PWM1=0x03;    //ÔºàP3.6Ôºâ8‰ΩçPWMÊ®°Âºè
 418   1        //PCA_PWM0=0x03;  //ÔºàP3.5Ôºâ8‰ΩçPWMÊ®°Âºè
 419   1        hw_pwm_dis(1);
 420   1        hw_pwm_dis(2);
 421   1      #elif STC_8H
                //Á°¨‰ª∂CH1/CH2/CH6/CH7ÂØπÂ∫îPWM6_2/PWM5_2/PWM8_2/PWM7_2
                //stc8h PWMËæìÂá∫‰ΩøËÉΩ
                #define ENO5P             0x01
                #define ENO6P             0x04
                #define ENO7P             0x10
                #define ENO8P             0x40
                //pwm ÂàÜËæ®Áéá„ÄÅÈ¢ëÁéá ÂØÑÂ≠òÂô®ÈÖçÁΩÆÂÄºËÆ°ÁÆó
                #define ANALOG_PWM_ARR_8BITS  (256-2)
                //#define ANALOG_PWM_ARR_10BITS (1024-2)
                #define ANALOG_PWM_RANGE      (ANALOG_PWM_ARR_8BITS+1)
                #define ANALOG_PWM_PSCR_1KHZ  ((FOSC/ANALOG_PWM_RANGE/1000)-1)
                //stc8h PWMÂºïËÑöÈÄâÊã©
                #define PWM5_SW_P17       1
                #define PWM6_SW_P54       (1<<2)
                #define PWM7_SW_P33       (1<<4)
                #define PWM8_SW_P34       (1<<6)
              
                PWMB_BKR = 0x00;          //ÂÖ≥Èó≠‰∏ªËæìÂá∫ÔºåÂØÑÂ≠òÂô®Êó†ÂÜô‰øùÊä§
                PWMB_CR2 = 0x00;  
                PWMB_CR1 = 0x00;          //ÂÖ≥Èó≠ËÆ°Êï∞Âô®
                PWMB_CCER1 = 0x00;        //ÂÖ≥Èó≠ÈÄöÈÅìÔºöPWM5/PWM6
                PWMB_CCER2 = 0x00;        //ÂÖ≥Èó≠ÈÄöÈÅìÔºöPWM7/PWM8
                PWMB_CCMR1 = 0x60|0x08;   //ËÆæÁΩÆÈÄöÈÅì5Ê®°ÂºèÔºöPWMÊ®°Âºè1 | PWMn_CCRxÈ¢ÑË£ÖËΩΩ‰ΩøËÉΩ + ËæìÂá∫
                PWMB_CCMR2 = 0x60|0x08;   //ËÆæÁΩÆÈÄöÈÅì6Ê®°ÂºèÔºö
                PWMB_CCMR3 = 0x60|0x08;   //ËÆæÁΩÆÈÄöÈÅì7Ê®°ÂºèÔºö
                PWMB_CCMR4 = 0x60|0x08;   //ËÆæÁΩÆÈÄöÈÅì8Ê®°ÂºèÔºö
                PWMB_CCER1 = 0x11;        //ÂºÄÂêØÈÄöÈÅìÔºöPWM5/PWM6
                PWMB_CCER2 = 0x11;        //ÂºÄÂêØÈÄöÈÅìÔºöPWM7/PWM8
                PWMB_CCR5 = 0;            //ËÆæÁΩÆÂç†Á©∫ÊØîÊó∂Èó¥
                PWMB_CCR6 = 0;            //ËÆæÁΩÆÂç†Á©∫ÊØîÊó∂Èó¥
                PWMB_CCR7 = 0;            //ËÆæÁΩÆÂç†Á©∫ÊØîÊó∂Èó¥
                PWMB_CCR8 = 0;            //ËÆæÁΩÆÂç†Á©∫ÊØîÊó∂Èó¥
                //ËÆæÁΩÆÂë®ÊúüÊó∂Èó¥ÔºåÂøÖÈ°ªÂÖàÂÜôÈ´òÂ≠óËäÇPWMB_ARRHÔºõÂêë‰∏äËÆ°Êï∞ËåÉÂõ¥‰∏∫[0~ARR]
                PWMB_ARR = ANALOG_PWM_ARR_8BITS;;
                //ÂØπÁ≥ªÁªüÊó∂ÈíüÂàÜÈ¢ëÔºåÂøÖÈ°ªÂÖàÂÜôÈ´òÂ≠óËäÇPWMB_PSCRHÔºõPWMB_PSCRÂØπÁ≥ªÁªüÊó∂ÈíüÂàÜÈ¢ëÂæóÂà∞PWMBÊó∂Èí
             -üÔºåPWMB_PSCR+1‰∏™Á≥ªÁªüÊó∂ÈíüËæìÂá∫‰∏Ä‰∏™PWMBÊó∂Èíü
                PWMB_PSCR = ANALOG_PWM_PSCR_1KHZ;
                PWMB_PS = PWM5_SW_P17 | PWM6_SW_P54 | PWM7_SW_P33 | PWM8_SW_P34; //È´òÁ∫ß PWM ÈÄöÈÅìËæìÂá∫ËÑöÈÄâÊã©‰Ωç
                PWMB_DTR = 0;             //Ê≠ªÂå∫Êó∂Èó¥
                PWMB_RCR = 0;             //ÈáçÂ§çËÆ°Êï∞Âô®
                PWMB_ENO = 0;             //PWMBÊâÄÊúâÁ´ØÂè£Á¶ÅÊ≠¢ËæìÂá∫ // hw_pwm_dis(1/2/6/7);
                PWMB_BKR = 0x80;          //‰ΩøËÉΩ‰∏ªËæìÂá∫
                PWMB_EGR = 0x01;          //ÈáçÊñ∞ÂàùÂßãÂåñËÆ°Êï∞Âô®ÔºåÂπ∂‰∫ßÁîü‰∏Ä‰∏™Êõ¥Êñ∞‰∫ã‰ª∂„ÄÇ
                PWMB_CR1 = 0x01;          //ARR‰∏çÁºìÂÜ≤ÔºåÂêë‰∏äËÆ°Êï∞Ê®°ÂºèÔºåÂºÄÂßãÂêë‰∏äËÆ°Êï∞
                
              #endif
 467   1      }
 468          
 469          #if STC_15W408AS
 470          
 471          void hw_pwm_en(u8 ch)
 472          {
 473   1        if(ch==1)       CCAPM2=0x42;  //PCAÊØîËæÉ/ÊçïËé∑ÂØÑÂ≠òÂô®ÔºöÂÖÅËÆ∏ÊØîËæÉÂô®ÂäüËÉΩÔºåÂÖÅËÆ∏ËÑâÂÆΩË∞ÉËäÇËæìÂá∫
 474   1        else if(ch==2)  CCAPM1=0x42;
 475   1      }
 476          
 477          void hw_pwm_dis(u8 ch)
C51 COMPILER V9.59.0.0   LOLI3_RECV_SYS_STC                                                12/13/2023 00:12:42 PAGE 9   

 478          {
 479   1        if(ch==1)       CCAPM2 = 0;   //PCAÊØîËæÉ/ÊçïËé∑ÂØÑÂ≠òÂô®ÔºöÁ¶ÅÊ≠¢ÊØîËæÉÂô®ÂäüËÉΩÔºåÁ¶ÅÊ≠¢ËÑâÂÆΩË∞ÉËäÇËæìÂá∫
 480   1        else if(ch==2)  CCAPM1 = 0;
 481   1      }
 482          
 483          #elif STC_8H
              
              void hw_pwm_en(u8 ch)
              {
                if(ch==1)       PWMB_ENO |= ENO6P;
                else if(ch==2)  PWMB_ENO |= ENO5P;
                else if(ch==6)  PWMB_ENO |= ENO8P;
                else if(ch==7)  PWMB_ENO |= ENO7P;
              }
              
              void hw_pwm_dis(u8 ch)
              {
                if(ch==1)       PWMB_ENO &= ~ENO6P;
                else if(ch==2)  PWMB_ENO &= ~ENO5P;
                else if(ch==6)  PWMB_ENO &= ~ENO8P;
                else if(ch==7)  PWMB_ENO &= ~ENO7P;
              }
              
              #endif
 502          
 503          // ËÆæÁΩÆpragma NOAREGSÔºåÂØÑÂ≠òÂô®ÁªÑ‰∏ç‰ΩøÁî®ÁªùÂØπÂú∞ÂùÄÔºå‰ª•‰æøÂú®‰ΩøÁî®usingÁöÑ‰∏≠Êñ≠ÂáΩÊï∞‰∏≠Ë∞ÉÁî®
 504          #pragma NOAREGS
 505          void hw_pwm_set(u8 ch, u8 pwm)
 506          {
 507   1      #if STC_15W408AS
 508   1      /*-----------------------------------------------------------------------------/
 509   1      ÊØîËæÉÂÄºÔºö{EPCnL,CCAPnL[7:0]}
 510   1      ÂΩìÂâçÂÄºÔºö{0,CL[7:0]}ÔºåÁî±CCPËÆ°Êï∞Âô®‰Ωé8‰ΩçCL‰∏é0ÁªÑÊàê9‰ΩçÊï∞ÊçÆÔºåÊï∞ÊçÆËåÉÂõ¥[0,255]
 511   1      
 512   1      8‰ΩçpwmÊ®°ÂºèÂàíÂàÜ256Á≤æÂ∫¶ÔºåÊ†πÊçÆSTC15ÊâãÂÜåP942ÔºåÂΩìÂâçÂÄºÂ§ß‰∫éÁ≠â‰∫éÊØîËæÉÂÄºÊó∂ËæìÂá∫1 --> ÊØîËæÉ
             -ÂÄº==‰ΩéÁîµÂπ≥Êï∞Èáè
 513   1      ÂΩìCCAPnL==255-pwm --> pwm[0-255]==CCAPnL[255-0]==‰ΩéÁîµÂπ≥[255/256-0/256]==È´òÁîµÂπ≥[1/256-256/256]
 514   1      ‰∏∫ËæìÂá∫ÂÖ®‰ΩéÁîµÂπ≥ÔºåÂΩìpwm<MININUMÊó∂ÂÅöÁâπÊÆäÂ§ÑÁêÜÔºåCCAPnL‰∏éEPCnL(Ê≠§Êó∂‰∏∫1)ÁªÑÊàê9‰ΩçÊØîËæÉÂÄºÔº
             -å‰ª•Êèê‰æõÂÖ®0ËæìÂá∫„ÄÇ
 515   1      /----------------------------------------------------------------------------*/
 516   1      
 517   1      // stc15w HW_PWM_MINNUMÊúÄ‰ΩéÂÄºÈúÄ‰∏∫1ÊâçËÉΩ‰øùËØÅËæìÂá∫ÂÖ®‰ΩéÁîµÂπ≥„ÄÇ‰ª•‰∏ãÂÆèÂØπHW_PWM_MINNUMËøõË°åÂ§Ñ
             -ÁêÜ„ÄÇ
 518   1      #if (LOLI3_RECV_PWM_MINNUM/4 >= 1)
 519   1        #define HW_PWM_MINNUM   (LOLI3_RECV_PWM_MINNUM/4)
 520   1      #else
                #define HW_PWM_MINNUM   1
              #endif
 523   1      
 524   1        if(ch==1)
 525   1        {
 526   2          if( pwm>=HW_PWM_MINNUM )  PCA_PWM2=0x00;  // CCAPxH&CCAPnLÁ¨¨9‰ΩçÊï∞‰∏∫0
 527   2          else                      PCA_PWM2=0x03;  // CCAPxH&CCAPnLÁ¨¨9‰ΩçÊï∞‰∏∫1
 528   2          CCAP2H = 255-pwm;         // CLÊ∫¢Âá∫Êó∂EPCnH&CCAPnHÊï∞ÊçÆÊâçËΩΩÂÖ•EPCnL&CCAPnL
 529   2        }
 530   1        else if(ch==2)
 531   1        {
 532   2          if( pwm>=HW_PWM_MINNUM )  PCA_PWM1=0x00;
 533   2          else                      PCA_PWM1=0x03;
 534   2          CCAP1H = 255-pwm;
 535   2        }
 536   1      #elif STC_8H
C51 COMPILER V9.59.0.0   LOLI3_RECV_SYS_STC                                                12/13/2023 00:12:42 PAGE 10  

              /*-----------------------------------------------------------------------------/
              
              Á°¨‰ª∂CH1/CH2/CH6/CH7ÂØπÂ∫îPWM6_2/PWM5_2/PWM8_2/PWM7_2
                
              /----------------------------------------------------------------------------*/
              #if (LOLI3_RECV_PWM_MINNUM/4 >= 1)
                #define HW_PWM_MINNUM   (LOLI3_RECV_PWM_MINNUM/4)
              #else
                #define HW_PWM_MINNUM   1
              #endif
                
                if(ch==1)
                {
                  if( pwm>=HW_PWM_MINNUM )  PWMB_CCR6 = pwm;
                  else                      PWMB_CCR6 = 0;
                }
                else if(ch==2)
                {
                  if( pwm>=HW_PWM_MINNUM )  PWMB_CCR5 = pwm;
                  else                      PWMB_CCR5 = 0;
                }
                else if(ch==6)
                {
                  if( pwm>=HW_PWM_MINNUM )  PWMB_CCR8 = pwm;
                  else                      PWMB_CCR8 = 0;
                }
                else if(ch==7)
                {
                  if( pwm>=HW_PWM_MINNUM )  PWMB_CCR7 = pwm;
                  else                      PWMB_CCR7 = 0;
                }
                
              /*-----------------------------------------------------------------------------/
              /----------------------------------------------------------------------------*/
              #endif
 572   1      }
 573          #pragma AREGS
 574          
 575          /*////////////////////////////////////////////////////////////////////////////*/
 576          
 577          void LED_on(void)
 578          {
 579   1        LED_ON();
 580   1      }
 581          
 582          void LED_off(void)
 583          {
 584   1        LED_OFF();
 585   1      }
 586          
 587          /*////////////////////////////////////////////////////////////////////////////*/
 588          // NRF24L01 SPIÁ´ØÂè£IOÊ®°ÂºèÂàùÂßãÂåñ
 589          void SPI_init_0()
 590          {
 591   1        // set SCK/MOSI/NSS output mode, MISO input mode
 592   1        //ÈªòËÆ§ÂáÜÂèåÂêëIOÔºåÊó†ÈúÄÈÖçÁΩÆ‰ª£Á†Å
 593   1      }
 594          
 595          void SPI_init_1(void)
 596          {
 597   1        // then set SCK/MOSI 0, set NNS 1.
 598   1        SPI_SLAVE_DIS();
C51 COMPILER V9.59.0.0   LOLI3_RECV_SYS_STC                                                12/13/2023 00:12:42 PAGE 11  

 599   1        SPI_SCK_CLR();
 600   1        SPI_MOSI_CLR();
 601   1      }
 602          
 603          /*////////////////////////////////////////////////////////////////////////////*/
 604          //ROMÂ≠òÂÇ®
 605          u8 EEPROM_read(u16 addr)  //ËØªÊï∞ÊçÆ
 606          {
 607   1        IAP_CMD=0x01;
 608   1      
 609   1        IAP_ADDRH=addr>>8;
 610   1        IAP_ADDRL=addr;
 611   1      
 612   1        IAP_TRIG=0x5a;
 613   1        IAP_TRIG=0xa5;
 614   1        _nop_();
 615   1      
 616   1        return IAP_DATA;
 617   1      }
 618          
 619          void EEPROM_write(u16 addr,u8 byte) //ÂÜôÂÖ•Êï∞ÊçÆ
 620          {
 621   1        IAP_CMD=0x02;
 622   1        IAP_DATA=byte;
 623   1      
 624   1        IAP_ADDRH=addr>>8;
 625   1        IAP_ADDRL=addr;
 626   1      
 627   1        IAP_TRIG=0x5a;
 628   1        IAP_TRIG=0xa5;
 629   1        _nop_();
 630   1      }
 631          
 632          void EEPROM_cleanPage(u8 addrPage)  //Êì¶Èô§ÊâáÂå∫Êï∞ÊçÆ
 633          {
 634   1        IAP_CMD=0x03;
 635   1      
 636   1        IAP_ADDRH=(SIZE_EEPROM_PAGE*addrPage)>>8;
 637   1        IAP_ADDRL=0;
 638   1      
 639   1        IAP_TRIG=0x5a;
 640   1        IAP_TRIG=0xa5;
 641   1        _nop_();
 642   1      }
 643          
 644          /*////////////////////////////////////////////////////////////////////////////*/
 645          
 646          void hw_sys_init()
 647          {
 648   1        //Á¶ÅÊ≠¢ÊâÄÊúâ‰∏≠Êñ≠
 649   1        IE = 0;
 650   1        IE2= 0;
 651   1      
 652   1        //Á´ØÂè£ÂäüËÉΩÂàùÂßãÂåñ
 653   1        hw_io_chs_init();
 654   1        //ÂºÄÊú∫Âª∂Êó∂‰ª•ÈÅøËøáÁîµÊ∫êÊ≥¢Âä®
 655   1        hw_delay_ms(200); // ÂèÇÊï∞Á±ªÂûãu8Ôºå‰∏çÂ§ß‰∫é255„ÄÇ
 656   1        hw_delay_ms(200);
 657   1        //SBUSÂäüËÉΩÂàùÂßãÂåñ-------------------Ôºà‰ΩøÁî®ÂÆöÊó∂Âô®2Ôºâ
 658   1        hw_uart_init(UART_BPS); //init for debug and SBUS output
 659   1        //ÁîµÂéãÊµãÈáèÂäüËÉΩÂàùÂßãÂåñ
 660   1        hw_adc_init();
C51 COMPILER V9.59.0.0   LOLI3_RECV_SYS_STC                                                12/13/2023 00:12:42 PAGE 12  

 661   1        //Á≥ªÁªüÂøÉË∑≥ÂäüËÉΩÂàùÂßãÂåñ---------------ÔºàSTC15W‰ΩøÁî®PCAÂÆöÊó∂Âô®Ê®°Âùó0‰∏≠Êñ≠ / STC8H‰ΩøÁî®ÂÆöÊó∂Â
             -ô®1Ôºâ
 662   1        hw_tick_init();
 663   1        //ÈÄöÈÅìËæìÂá∫ÂäüËÉΩÂàùÂßãÂåñ---------------Ôºà‰ΩøÁî®ÂÆöÊó∂Âô®0Ôºâ
 664   1        hw_output_init();
 665   1        
 666   1        INTERRUPT_en(); // addin(20230925): delayÁöÑÂÆûÁé∞ÂèØËÉΩ‰æùËµñ‰∏≠Êñ≠ÔºõÊàñËÄÖÊäädelayÊõøÊç¢Êàêhw_delay_ms
             -?
 667   1      }
 668          
 669          /******************************************************************************/
 670          /*-DO NOT ADD YOUR CODE AFTER HERE!-*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\-WIDTH: 80-*/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    572    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       3
   IDATA SIZE       =      6    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
