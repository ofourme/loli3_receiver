C51 COMPILER V9.59.0.0   LOLI3_RECV_SYS_STC                                                12/13/2023 00:12:42 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE LOLI3_RECV_SYS_STC
OBJECT MODULE PLACED IN .\Objects\loli3_recv_sys_stc.obj
COMPILER INVOKED BY: C:\bin\Keil_v5\C51\BIN\C51.EXE ..\port\loli3_recv_sys_stc.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\port
                    -;..\src) DEBUG OBJECTEXTEND PRINT(.\Listings\loli3_recv_sys_stc.lst) TABS(2) OBJECT(.\Objects\loli3_recv_sys_stc.obj)

line level    source

   1          /*
   2          ********************************************************************************
   3          *                             ---ofme---
   4          *           Copyleft (c) 2021-2023, å¾®é£å±±è°· / ofourme@163.com
   5          *           License: LGPL
   6          *
   7          *   LOLI3_RECV_SYS_STC.C-V1.0.0 (2023.Oct.25th)
   8          *   ç¨‹åºåŒ¹é…ç¡¬ä»¶ï¼šSTC15W / STC8H
   9          *   ç¡¬ä»¶å›ºå®šè¿è¡Œé¢‘ç‡ï¼š12MHz
  10          *
  11          ********************************************************************************
  12          */
  13          
  14          #define __LOLI3_RECV_SYS_STC_C__
  15          
  16          /*-DO NOT ADD YOUR CODE BEFORE HERE!-*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\-WIDTH: 80-*/
  17          /******************************************************************************/
  18          
  19          #include "loli3_recv_port.h"
  20          
  21          /*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
  22          
  23          idata volatile u32 _sys_ms;         // å½“å‰mså€¼
  24          idata volatile u16 _sys_us_target;  // ä¸­æ–­å‘ç”Ÿç›®æ ‡uså€¼
  25          
  26          #if defined( SBUS_BPS_115200 )
                #define UART_BPS  UART_BPS_115200
              #elif defined ( SBUS_BPS_9600 )
                #define UART_BPS  UART_BPS_9600
              #else
  31            #define UART_BPS  UART_BPS_100K
  32          #endif
  33          
  34          /*////////////////////////////////////////////////////////////////////////////*/
  35          //å»¶æ—¶å‡½æ•°ï¼Œä»…ä¾èµ–ç³»ç»Ÿæ—¶é’Ÿï¼Œæ— éœ€å…¶ä»–æ¨¡å—åˆå§‹åŒ–
  36          void hw_delay_1ms()   //@12.000MHz
  37          {
  38   1        unsigned char i, j;
  39   1        i = 12;
  40   1        j = 168;
  41   1        do
  42   1        {
  43   2          while (--j);
  44   2        } while (--i);
  45   1      }
  46          
  47          void hw_delay_ms(u8 ms)
  48          {
  49   1        while(ms--) hw_delay_1ms();
  50   1      }
  51          
  52          /*////////////////////////////////////////////////////////////////////////////*/
  53          void hw_io_chs_init()
  54          {
C51 COMPILER V9.59.0.0   LOLI3_RECV_SYS_STC                                                12/13/2023 00:12:42 PAGE 2   

  55   1      #if STC_15W408AS
  56   1        //stc15w IOå£é»˜è®¤å‡†åŒå‘å£æ¨¡å¼ï¼Œæ— éœ€ä¿®æ”¹PxM0å’ŒPxM1
  57   1        CH1=0;
  58   1        CH2=0;
  59   1        CH3=0;
  60   1        CH4=0;
  61   1        CH5=0;
  62   1        CH6=0;
  63   1        CH7=0;
  64   1        CH8=0;
  65   1      #elif STC_8H
                // P1+P3+P5.4 ç”±é«˜é˜»æ”¹ä¸ºåŒå‘æ¨¡å¼
                P1M0 = 0x00;
                P1M1 = 0x00;
                P3M0 = 0x00;
                P3M1 = 0x00;
                P5M0 = 0xf7;
                P5M1 = 0xf7;
                
                CH1=0;
                CH2=0;
                CH3=0;
                CH4=0;
                CH5=0;
                CH6=0;
                CH7=0;
                CH8=0;
              
              #endif
  84   1      }
  85          
  86          void hw_io_cho_init()
  87          {
  88   1      // CH5 è®¾ä¸ºæ¨æŒ½è¾“å‡ºæ¨¡å¼
  89   1      #if defined   PIN_CH_OUT_P31
                P3M0=1<<1;
              #elif defined PIN_CH_OUT_P33
  92   1        P3M0=1<<3;
  93   1      #elif defined PIN_CH_OUT_P37
                P3M0=1<<7;
              #else
                  #err "CH out pin not set OUTPUT."
              #endif
  98   1      }
  99          void hw_io_cho_clr()
 100          {
 101   1      #if defined PIN_CH_OUT_P31
                P31 = 0;
              #elif defined PIN_CH_OUT_P33
 104   1        P33 = 0;
 105   1      #elif defined PIN_CH_OUT_P37
                P37 = 0;
              #else
                #err "PIN_CH_OUT not CLR."
              #endif
 110   1      }
 111          void hw_io_cho_set()
 112          {
 113   1      #if defined PIN_CH_OUT_P31
                P31 = 1;
              #elif defined PIN_CH_OUT_P33
 116   1        P33 = 1;
C51 COMPILER V9.59.0.0   LOLI3_RECV_SYS_STC                                                12/13/2023 00:12:42 PAGE 3   

 117   1      #elif defined PIN_CH_OUT_P37
                P37 = 1;
              #else
                #err "PIN_CH_OUT not SET."
              #endif
 122   1      }
 123          
 124          void hw_io_chi_init()
 125          {
 126   1      //  CH6=1;  // é»˜è®¤å‡†åŒå‘å£æ¨¡å¼ï¼Œè®¾ç½®1å¼±ä¸Šæ‹‰ï¼Œä¸”å…è®¸å¤–éƒ¨æ‹‰ä½åˆ°0ã€‚
 127   1      #if defined PIN_CH_IN_P32
 128   1        P32 = 1;
 129   1      #elif defined PIN_CH_IN_P36
                P36 = 1;
              #else
                #err "PIN_CH_IN not set INPUT."
              #endif
 134   1      }
 135          
 136          u8 hw_io_chi_get()
 137          {
 138   1      #if defined PIN_CH_IN_P32
 139   1        return (u8)(P32);
 140   1      #elif defined PIN_CH_IN_P36
                return (u8)(P36);
              #else
                #err "PIN_CH_IN not GET."
              #endif
 145   1      }
 146          
 147          void hw_io_chs_pushpull()
 148          {
 149   1        CH1=0;
 150   1        CH2=0;
 151   1        CH3=0;
 152   1        CH4=0;
 153   1        CH5=0;
 154   1        CH6=0;
 155   1      //stc51 uart å£è¾“å‡º0å°†å¯¼è‡´ä¸²å£æ— æ³•è¾“å‡º//CH7=0;//PIN_SBUS=1;
 156   1        CH8=0;
 157   1      
 158   1        //æ¥ä¸‹æ¥å¯å°†é€šé“è¾“å‡ºIOå£é…ç½®ä¸ºæ¨æŒ½æ¨¡å¼ï¼Œä¿è¯æ­£å¸¸é©±åŠ¨ç”µè°ƒä¸èˆµæœº
 159   1        //ä¸é…ç½®æ¨æŒ½ä¼¼ä¹ä¹Ÿå¯ä»¥ï¼Ÿé…ç½®æ¨æŒ½ä¼šå¦å½±å“ä¸²å£ä¼ è¾“æ•°æ®ï¼Ÿ
 160   1        P3M0=0xFF;
 161   1      }
 162          
 163          /*////////////////////////////////////////////////////////////////////////////*/
 164          // ä¸²å£é€šè®¯ï¼Œä½¿ç”¨å®šæ—¶å™¨2
 165          void hw_uart_init(u8 bps)
 166          {
 167   1        SCON = 0xD0;    //9ä½æ•°æ®,å¯å˜æ³¢ç‰¹ç‡
 168   1        AUXR |= 0x01;   //ä¸²å£1é€‰æ‹©å®šæ—¶å™¨2ä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨
 169   1        AUXR |= 0x04;   //å®šæ—¶å™¨2æ—¶é’Ÿä¸ºFosc,å³1T
 170   1      
 171   1        if(bps==UART_BPS_9600)  //9600bps@12.000MHz
 172   1        {
 173   2          T2L = 0xC7;
 174   2          T2H = 0xFE;
 175   2        }
 176   1        else if(bps==UART_BPS_115200) //115200bps@12.000MHz
 177   1        {
 178   2          T2L = 0xE6;   //è®¾ç½®å®šæ—¶åˆå§‹å€¼
C51 COMPILER V9.59.0.0   LOLI3_RECV_SYS_STC                                                12/13/2023 00:12:42 PAGE 4   

 179   2          T2H = 0xFF;   //è®¾ç½®å®šæ—¶åˆå§‹å€¼
 180   2        }
 181   1        else      //100000bps@12.000MHz
 182   1        {
 183   2          T2L = 0xE2;   //è®¾å®šå®šæ—¶åˆå€¼
 184   2          T2H = 0xFF;   //è®¾å®šå®šæ—¶åˆå€¼
 185   2        }
 186   1      
 187   1        PIN_SBUS_SET();
 188   1        AUXR |= 0x10;   //å®šæ—¶å™¨2å¼€å§‹è®¡æ—¶
 189   1      }
 190          
 191          void UART_pushByte(char c)
 192          {
 193   1          if(TI)TI=0;
 194   1          ACC=c;
 195   1          TB8=P;
 196   1          SBUF=ACC;
 197   1      }
 198          
 199          void hw_uart_puts(const char* str)
 200          {
 201   1        while(*str)
 202   1        {
 203   2          UART_pushByte(*str++);
 204   2          while(!TI); // bugfix(20211220): å°†æ­¤å¥ç§»åˆ°UART_pushByte()åé¢ï¼Œé˜²æ­¢æ­»å¾ªç¯ã€‚å‰¯ä½œç”¨æ˜¯å‡
             -½æ•°å¤–éƒ¨ä¹‹å‰ä½¿ç”¨UART_pushByte()å¯èƒ½æœªå‘é€å®Œæˆå°±è¢«ç»ˆæ­¢ã€‚
 205   2        }
 206   1        UART_pushByte('\r');
 207   1        while(!TI);
 208   1        UART_pushByte('\n');
 209   1        while(!TI);
 210   1      }
 211          
 212          /*////////////////////////////////////////////////////////////////////////////*/
 213          //ç”µå‹æµ‹é‡æ¨¡å—ï¼šæ¥æ”¶æœºç¨‹åºå¯¹ADCè¿”å›æ•°æ®æŒ‰10ä½å¤„ç†ï¼Œç§»æ¤ä¸åŒç¡¬ä»¶éœ€æ³¨æ„ä¿æŒ
             -ä¸€è‡´
 214          //ç”µå‹æµ‹é‡åŠŸèƒ½åˆå§‹åŒ–
 215          void hw_adc_init()
 216          {
 217   1        //å°†ADè¾“å…¥å£è®¾ç½®ä¸ºé«˜é˜»è¾“å…¥ï¼Œè¯¦è§STC15æ‰‹å†ŒP400è¦æ±‚
 218   1      #if defined   PIN_ADC_P1X
 219   1        P1M1 |=  1<<PIN_ADC_P1X;  //8é€šé“æ¥æ”¶æœºä½¿ç”¨P1.xå£åšADCè¾“å…¥å£
 220   1      #else
                  #err "ADC pin not inited."
              #endif
 223   1      
 224   1      #if STC_15W408AS
 225   1        ADC_CONTR=0x80;   //ADCä¸Šç”µ
 226   1        hw_delay_ms(2);   //å»¶æ—¶ç­‰å¾…ADCæ¨¡å—ç¨³å®š
 227   1      
 228   1        P1ASF=0x00;       //ä¸è¯»å–P1å£ï¼Œè€Œæ˜¯ä¸‹æ¬¡è¯»å–å†…éƒ¨å‚è€ƒç”µå‹ä¿å­˜åœ¨_adc_icé‡Œ
 229   1        ADC_CONTR=0x88;   //å¯åŠ¨è½¬æ¢
 230   1        while(ADC_CONTR&0x10==0);//ç­‰å¾…è½¬æ¢å®Œæˆ
 231   1      #elif STC_8H
                // ADCæ§åˆ¶å¯„å­˜å™¨ADC_CONTRé…ç½®ä½ï¼šæ‰“å¼€ADè½¬æ¢å™¨ç”µæº/å¯åŠ¨ADè½¬æ¢/è½¬æ¢ç»“æŸæ ‡å¿—ä½
                #define ADC_POWER 7
                #define ADC_START 6
                #define ADC_FLAG  5
                ADCTIM = 0x3F;
                ADC_CONTR = (1<<ADC_POWER | 0<<ADC_START | 0<<ADC_FLAG);
                hw_delay_ms(2);   //å»¶æ—¶ç­‰å¾…ADCæ¨¡å—ç¨³å®š
C51 COMPILER V9.59.0.0   LOLI3_RECV_SYS_STC                                                12/13/2023 00:12:42 PAGE 5   

              
                ADC_CONTR = (1<<ADC_POWER | 1<<ADC_START | 0<<ADC_FLAG)|15; // è¯»å–å†…éƒ¨å‚è€ƒç”µå‹ä¿å­˜åœ¨_adc_icé‡
             -Œ
                while (!(ADC_CONTR & (1<<ADC_FLAG))); ////ç­‰å¾…è½¬æ¢å®Œæˆ
              #endif
 243   1      }
 244          //ADè½¬æ¢é¢„å¯åŠ¨
 245          void hw_adc_open(u8 i)  //0ï¼šå†…éƒ¨å‚è€ƒç”µå‹ï¼›1ï¼šå¤–éƒ¨ç”µå‹
 246          {
 247   1      #if STC_15W408AS
 248   1        if(i&0x01)
 249   1        {
 250   2      #if defined   PIN_ADC_P1X
 251   2          P1ASF=0x01<<PIN_ADC_P1X;    //P1å£æ¨¡æ‹ŸåŠŸèƒ½æ§åˆ¶å¯„å­˜å™¨ï¼šp1.xä½œä¸ºæ¨¡æ‹ŸåŠŸèƒ½A/Dä½¿ç”¨ï¼Œä¸‹æ¬¡è
             -¯»å–ç”µæ± ç”µå‹ä¿å­˜åœ¨_adc_batté‡Œ
 252   2          ADC_CONTR= 1<<7 | 0<<4 | 1<<3 | PIN_ADC_P1X<<0;   //ADCæ§åˆ¶å¯„å­˜å™¨ï¼šæ‰“å¼€ADè½¬æ¢å™¨ç”µæº/æ¸…é™¤è½
             -¬æ¢ç»“æŸæ ‡å¿—ä½/å¯åŠ¨ADè½¬æ¢/p1.xä½œADè¾“å…¥
 253   2      #else
                  #err "ADC pin not P1.x"
              #endif
 256   2        }
 257   1        else
 258   1        {
 259   2          P1ASF=0x00;       //ä¸è¯»å–P1å£ï¼Œè€Œæ˜¯ä¸‹æ¬¡è¯»å–å†…éƒ¨å‚è€ƒç”µå‹ä¿å­˜åœ¨_adc_icé‡Œ
 260   2          ADC_CONTR=0x88;   //å¯åŠ¨è½¬æ¢
 261   2        }
 262   1      #elif STC_8H
                if(i&0x01)
                {
              #if defined   PIN_ADC_P1X
                  ADC_CONTR = (1<<ADC_POWER | 1<<ADC_START | 0<<ADC_FLAG) | PIN_ADC_P1X ;
              #else
                  #err "ADC pin not P1.x"
              #endif
                }
                else
                {
                  ADC_CONTR = (1<<ADC_POWER | 1<<ADC_START | 0<<ADC_FLAG) | 15 ;
                }
              #endif
 276   1      }
 277          
 278          //è¯»å–ä¸Šä¸€æ¬¡å¯åŠ¨ADè½¬æ¢è·å¾—çš„å€¼ã€‚
 279          //æœ¬å‡½æ•°å®ç°æ²¡æœ‰åˆ¤æ–­è½¬æ¢æ˜¯å¦å®Œæˆï¼Œä½¿ç”¨æ—¶éœ€æ³¨æ„æ—¶é—´é—´éš”ã€‚
 280          u16 hw_adc_read()
 281          {
 282   1        u16 adc;
 283   1      
 284   1      #if STC_15W408AS
 285   1        // ADC_RES[7:0] & ADC_RESL[1:0] ç»„æˆ10ä½ç»“æœ // 20230813
 286   1        adc=ADC_RES;
 287   1        adc<<=2,adc|=ADC_RESL;
 288   1      #elif STC_8H
                adc = ((u16)ADC_RES<<2)|(ADC_RESL>>6);
              #endif  
 291   1        return adc;
 292   1      }
 293          
 294          /*////////////////////////////////////////////////////////////////////////////*/
 295          
 296          void hw_tick_init()
 297          {
C51 COMPILER V9.59.0.0   LOLI3_RECV_SYS_STC                                                12/13/2023 00:12:42 PAGE 6   

 298   1      #if STC_15W408AS
 299   1        //ä»»åŠ¡å®šæ—¶å™¨ä¸­æ–­åˆå§‹åŒ–ï¼ˆä½¿ç”¨PCAå®šæ—¶å™¨æ¨¡å—0ä¸­æ–­ï¼‰
 300   1        _sys_ms = 0;
 301   1        CCON =0x00;     //PCAæ§åˆ¶å¯„å­˜å™¨ï¼šåœæ­¢PCAå®šæ—¶å™¨ï¼Œæ¸…é™¤ä¸­æ–­æ ‡å¿—
 302   1        CL=0;CH=0;      //å¤ä½PCAè®¡æ•°å™¨
 303   1        CMOD=0x00;      //PCAå·¥ä½œæ¨¡å¼å¯„å­˜å™¨ï¼šç©ºé—²æ¨¡å¼ä¸‹ç»§ç»­å·¥ä½œï¼Œç³»ç»Ÿæ—¶é’Ÿ/12ï¼Œè®¡æ•°æº¢å‡ºä¸­
             -æ–­ç¦æ­¢
 304   1        _sys_us_target = 1000;  //1 ms
 305   1        CCAP0L = _sys_us_target;
 306   1        CCAP0H = _sys_us_target >> 8;
 307   1        CCAPM0 = 0x49;  //PCAæ¨¡å—0çš„æ¯”è¾ƒ/æ•è·å¯„å­˜å™¨ï¼šå…è®¸æ¯”è¾ƒå™¨åŠŸèƒ½ï¼ŒåŒ¹é…ç½®ä½CCONæ ‡å¿—ä½C
             -CF0ï¼Œä½¿èƒ½CCF0ä¸­æ–­
 308   1      
 309   1      #elif STC_8H
                //ä»»åŠ¡å®šæ—¶å™¨ä¸­æ–­åˆå§‹åŒ–ï¼ˆä½¿ç”¨å®šæ—¶å™¨1ä¸­æ–­ï¼‰
                // ç³»ç»Ÿè®¡æ—¶å˜é‡åˆå§‹åŒ–
                _sys_ms = 0;
                _sys_us_target = 0; // åœ¨STC8Hçš„å®ç°ä¸­ï¼Œç”¨äºç¼“å­˜usè®¡æ•°
                //T1è®¾ç½®ä¸ºæ¨¡å¼0ï¼š16ä½è‡ªåŠ¨é‡è£…å®šæ—¶å™¨ï¼Œå½“æº¢å‡ºæ—¶å°†RL_TH1å’ŒRL_TL1å­˜æ”¾çš„å€¼è‡ªåŠ¨é‡è£
             -…å…¥TH1å’ŒTL1ä¸­
                TMOD &= 0x0F; // é«˜4ä½æ¸…é›¶
                TMOD |= 0x00; // è™šæ‹Ÿèµ‹å€¼ï¼Œé«˜4ä½èµ‹å€¼0
                AUXR &= ~(0x40);//é»˜è®¤12Tæ¨¡å¼
                IE=0x08; //å…è®¸T1ä¸­æ–­
                TH1 = (0x10000-FOSC/12/1000000*1000)>>8;
                TL1 = (0x10000-FOSC/12/1000000*1000);
              
              #endif
 323   1      }
 324          
 325          #if FUNC_MILLIS_EN
              u32 millis(void)
              {
                u32 temp;
              
              #if STC_15W408AS
                CCAPM0 = 0x48;  // bugfix(20230902): disable CCF0 interrupt, not disable T0 interrupt
                temp = _sys_ms;
                CCAPM0 = 0x49;  //enable PCA interrupt.
              #elif STC_8H
                ET1 = 0;
                temp = _sys_ms;
                ET1 = 1;
              #endif
                return temp;
              }
              #endif
 342          
 343          #if FUNC_MICROS_EN
 344          u16 micros(void)
 345          {
 346   1      #if STC_15W408AS
 347   1      
 348   1        u8 H0,H1,L;
 349   1      
 350   1        H0 = CH;  // read PCA clock time.
 351   1        L  = CL;
 352   1        H1 = CH;
 353   1        if(H1!=H0) L=0;
 354   1      
 355   1        return ((u16)H1<<8) | L;
 356   1      
C51 COMPILER V9.59.0.0   LOLI3_RECV_SYS_STC                                                12/13/2023 00:12:42 PAGE 7   

 357   1      #elif STC_8H
              
                u8 H0,H1,L;
                u16 T16, Tus;
              
                ET1 = 0;
                Tus = _sys_us_target;
                H0 = TH1; // read T1 clock time.
                L  = TL1;
                H1 = TH1;
                ET1 = 1;
              
                if(H1!=H0) L=0;
                T16 = (((u16)H1<<8)|L) - (0x10000-FOSC/12/1000000*1000);
              
                return (Tus+T16);
                
              #endif
 375   1      }
 376          #endif
 377          
 378          #if FUNC_DELAY_EN
 379          void delay(u16 i)
 380          {
 381   1        #if 1
 382   1        while(i--)
 383   1        hw_delay_1ms();
 384   1        #else
                
                #endif
 387   1      }
 388          #endif
 389          
 390          #if FUNC_DELAYMICROSECONDS_EN
              void delayMicroseconds(u16 us)
              {
                //v20220107: cur-start<us <<-->> (cur+0x10000)-start<us
                u16 start = micros();
                while(micros()-start<us);
              }
              #endif
 398          
 399          /*////////////////////////////////////////////////////////////////////////////*/
 400          //é€šé“èˆµé‡è¾“å‡º/pwmè¾“å‡ºåŠŸèƒ½åˆå§‹åŒ–
 401          void hw_output_init()
 402          {
 403   1      #if 1
 404   1      //èˆµé‡è¾“å‡ºæ§åˆ¶å®šæ—¶å™¨ä¸­æ–­åˆå§‹åŒ–ï¼Œé«˜ä¼˜å…ˆçº§ï¼ˆä½¿ç”¨å®šæ—¶å™¨0ï¼‰
 405   1        IP=0x02;      //T0ä¸­æ–­é«˜ä¼˜å…ˆçº§ï¼Œå…¶å®ƒä½ä¼˜å…ˆçº§
 406   1        //T0è®¾ç½®ä¸ºæ¨¡å¼0ï¼š16ä½è‡ªåŠ¨é‡è£…å®šæ—¶å™¨ï¼Œå½“æº¢å‡ºæ—¶å°†RL_TH0å’ŒRL_TL0å­˜æ”¾çš„å€¼è‡ªåŠ¨é‡è£
             -…å…¥TH0å’ŒTL0ä¸­
 407   1        TMOD &= 0xF0; //bugfix(20230812): 0x0Fæ”¹ä¸º0xF0
 408   1        TMOD |= 0x00;
 409   1        ET0 = 1; //å…è®¸T0ä¸­æ–­
 410   1      #endif
 411   1      
 412   1      #if STC_15W408AS
 413   1        //ç¡¬ä»¶PWMè¾“å‡ºåŠŸèƒ½åˆå§‹åŒ–ï¼ˆä½¿ç”¨PCAå®šæ—¶å™¨æ¨¡å—2/1çš„8ä½pwmåŠŸèƒ½ï¼ŒPCAè¾“å…¥æ—¶é’Ÿé¢‘ç‡1MH
             -zï¼Œpwmé¢‘ç‡=1MHz/256~=4kï¼‰
 414   1        P_SW1 &= ~(3<<4); //å¤–è®¾åŠŸèƒ½åˆ‡æ¢å¯„å­˜å™¨1ï¼šPWMå¼•è„šåˆ‡æ¢åˆ°P3.5~P3.7
 415   1        P_SW1 |= 1<<4;
 416   1        PCA_PWM2=0x03;    //ï¼ˆP3.7ï¼‰8ä½PWMæ¨¡å¼
C51 COMPILER V9.59.0.0   LOLI3_RECV_SYS_STC                                                12/13/2023 00:12:42 PAGE 8   

 417   1        PCA_PWM1=0x03;    //ï¼ˆP3.6ï¼‰8ä½PWMæ¨¡å¼
 418   1        //PCA_PWM0=0x03;  //ï¼ˆP3.5ï¼‰8ä½PWMæ¨¡å¼
 419   1        hw_pwm_dis(1);
 420   1        hw_pwm_dis(2);
 421   1      #elif STC_8H
                //ç¡¬ä»¶CH1/CH2/CH6/CH7å¯¹åº”PWM6_2/PWM5_2/PWM8_2/PWM7_2
                //stc8h PWMè¾“å‡ºä½¿èƒ½
                #define ENO5P             0x01
                #define ENO6P             0x04
                #define ENO7P             0x10
                #define ENO8P             0x40
                //pwm åˆ†è¾¨ç‡ã€é¢‘ç‡ å¯„å­˜å™¨é…ç½®å€¼è®¡ç®—
                #define ANALOG_PWM_ARR_8BITS  (256-2)
                //#define ANALOG_PWM_ARR_10BITS (1024-2)
                #define ANALOG_PWM_RANGE      (ANALOG_PWM_ARR_8BITS+1)
                #define ANALOG_PWM_PSCR_1KHZ  ((FOSC/ANALOG_PWM_RANGE/1000)-1)
                //stc8h PWMå¼•è„šé€‰æ‹©
                #define PWM5_SW_P17       1
                #define PWM6_SW_P54       (1<<2)
                #define PWM7_SW_P33       (1<<4)
                #define PWM8_SW_P34       (1<<6)
              
                PWMB_BKR = 0x00;          //å…³é—­ä¸»è¾“å‡ºï¼Œå¯„å­˜å™¨æ— å†™ä¿æŠ¤
                PWMB_CR2 = 0x00;  
                PWMB_CR1 = 0x00;          //å…³é—­è®¡æ•°å™¨
                PWMB_CCER1 = 0x00;        //å…³é—­é€šé“ï¼šPWM5/PWM6
                PWMB_CCER2 = 0x00;        //å…³é—­é€šé“ï¼šPWM7/PWM8
                PWMB_CCMR1 = 0x60|0x08;   //è®¾ç½®é€šé“5æ¨¡å¼ï¼šPWMæ¨¡å¼1 | PWMn_CCRxé¢„è£…è½½ä½¿èƒ½ + è¾“å‡º
                PWMB_CCMR2 = 0x60|0x08;   //è®¾ç½®é€šé“6æ¨¡å¼ï¼š
                PWMB_CCMR3 = 0x60|0x08;   //è®¾ç½®é€šé“7æ¨¡å¼ï¼š
                PWMB_CCMR4 = 0x60|0x08;   //è®¾ç½®é€šé“8æ¨¡å¼ï¼š
                PWMB_CCER1 = 0x11;        //å¼€å¯é€šé“ï¼šPWM5/PWM6
                PWMB_CCER2 = 0x11;        //å¼€å¯é€šé“ï¼šPWM7/PWM8
                PWMB_CCR5 = 0;            //è®¾ç½®å ç©ºæ¯”æ—¶é—´
                PWMB_CCR6 = 0;            //è®¾ç½®å ç©ºæ¯”æ—¶é—´
                PWMB_CCR7 = 0;            //è®¾ç½®å ç©ºæ¯”æ—¶é—´
                PWMB_CCR8 = 0;            //è®¾ç½®å ç©ºæ¯”æ—¶é—´
                //è®¾ç½®å‘¨æœŸæ—¶é—´ï¼Œå¿…é¡»å…ˆå†™é«˜å­—èŠ‚PWMB_ARRHï¼›å‘ä¸Šè®¡æ•°èŒƒå›´ä¸º[0~ARR]
                PWMB_ARR = ANALOG_PWM_ARR_8BITS;;
                //å¯¹ç³»ç»Ÿæ—¶é’Ÿåˆ†é¢‘ï¼Œå¿…é¡»å…ˆå†™é«˜å­—èŠ‚PWMB_PSCRHï¼›PWMB_PSCRå¯¹ç³»ç»Ÿæ—¶é’Ÿåˆ†é¢‘å¾—åˆ°PWMBæ—¶é’
             -Ÿï¼ŒPWMB_PSCR+1ä¸ªç³»ç»Ÿæ—¶é’Ÿè¾“å‡ºä¸€ä¸ªPWMBæ—¶é’Ÿ
                PWMB_PSCR = ANALOG_PWM_PSCR_1KHZ;
                PWMB_PS = PWM5_SW_P17 | PWM6_SW_P54 | PWM7_SW_P33 | PWM8_SW_P34; //é«˜çº§ PWM é€šé“è¾“å‡ºè„šé€‰æ‹©ä½
                PWMB_DTR = 0;             //æ­»åŒºæ—¶é—´
                PWMB_RCR = 0;             //é‡å¤è®¡æ•°å™¨
                PWMB_ENO = 0;             //PWMBæ‰€æœ‰ç«¯å£ç¦æ­¢è¾“å‡º // hw_pwm_dis(1/2/6/7);
                PWMB_BKR = 0x80;          //ä½¿èƒ½ä¸»è¾“å‡º
                PWMB_EGR = 0x01;          //é‡æ–°åˆå§‹åŒ–è®¡æ•°å™¨ï¼Œå¹¶äº§ç”Ÿä¸€ä¸ªæ›´æ–°äº‹ä»¶ã€‚
                PWMB_CR1 = 0x01;          //ARRä¸ç¼“å†²ï¼Œå‘ä¸Šè®¡æ•°æ¨¡å¼ï¼Œå¼€å§‹å‘ä¸Šè®¡æ•°
                
              #endif
 467   1      }
 468          
 469          #if STC_15W408AS
 470          
 471          void hw_pwm_en(u8 ch)
 472          {
 473   1        if(ch==1)       CCAPM2=0x42;  //PCAæ¯”è¾ƒ/æ•è·å¯„å­˜å™¨ï¼šå…è®¸æ¯”è¾ƒå™¨åŠŸèƒ½ï¼Œå…è®¸è„‰å®½è°ƒèŠ‚è¾“å‡º
 474   1        else if(ch==2)  CCAPM1=0x42;
 475   1      }
 476          
 477          void hw_pwm_dis(u8 ch)
C51 COMPILER V9.59.0.0   LOLI3_RECV_SYS_STC                                                12/13/2023 00:12:42 PAGE 9   

 478          {
 479   1        if(ch==1)       CCAPM2 = 0;   //PCAæ¯”è¾ƒ/æ•è·å¯„å­˜å™¨ï¼šç¦æ­¢æ¯”è¾ƒå™¨åŠŸèƒ½ï¼Œç¦æ­¢è„‰å®½è°ƒèŠ‚è¾“å‡º
 480   1        else if(ch==2)  CCAPM1 = 0;
 481   1      }
 482          
 483          #elif STC_8H
              
              void hw_pwm_en(u8 ch)
              {
                if(ch==1)       PWMB_ENO |= ENO6P;
                else if(ch==2)  PWMB_ENO |= ENO5P;
                else if(ch==6)  PWMB_ENO |= ENO8P;
                else if(ch==7)  PWMB_ENO |= ENO7P;
              }
              
              void hw_pwm_dis(u8 ch)
              {
                if(ch==1)       PWMB_ENO &= ~ENO6P;
                else if(ch==2)  PWMB_ENO &= ~ENO5P;
                else if(ch==6)  PWMB_ENO &= ~ENO8P;
                else if(ch==7)  PWMB_ENO &= ~ENO7P;
              }
              
              #endif
 502          
 503          // è®¾ç½®pragma NOAREGSï¼Œå¯„å­˜å™¨ç»„ä¸ä½¿ç”¨ç»å¯¹åœ°å€ï¼Œä»¥ä¾¿åœ¨ä½¿ç”¨usingçš„ä¸­æ–­å‡½æ•°ä¸­è°ƒç”¨
 504          #pragma NOAREGS
 505          void hw_pwm_set(u8 ch, u8 pwm)
 506          {
 507   1      #if STC_15W408AS
 508   1      /*-----------------------------------------------------------------------------/
 509   1      æ¯”è¾ƒå€¼ï¼š{EPCnL,CCAPnL[7:0]}
 510   1      å½“å‰å€¼ï¼š{0,CL[7:0]}ï¼Œç”±CCPè®¡æ•°å™¨ä½8ä½CLä¸0ç»„æˆ9ä½æ•°æ®ï¼Œæ•°æ®èŒƒå›´[0,255]
 511   1      
 512   1      8ä½pwmæ¨¡å¼åˆ’åˆ†256ç²¾åº¦ï¼Œæ ¹æ®STC15æ‰‹å†ŒP942ï¼Œå½“å‰å€¼å¤§äºç­‰äºæ¯”è¾ƒå€¼æ—¶è¾“å‡º1 --> æ¯”è¾ƒ
             -å€¼==ä½ç”µå¹³æ•°é‡
 513   1      å½“CCAPnL==255-pwm --> pwm[0-255]==CCAPnL[255-0]==ä½ç”µå¹³[255/256-0/256]==é«˜ç”µå¹³[1/256-256/256]
 514   1      ä¸ºè¾“å‡ºå…¨ä½ç”µå¹³ï¼Œå½“pwm<MININUMæ—¶åšç‰¹æ®Šå¤„ç†ï¼ŒCCAPnLä¸EPCnL(æ­¤æ—¶ä¸º1)ç»„æˆ9ä½æ¯”è¾ƒå€¼ï¼
             -Œä»¥æä¾›å…¨0è¾“å‡ºã€‚
 515   1      /----------------------------------------------------------------------------*/
 516   1      
 517   1      // stc15w HW_PWM_MINNUMæœ€ä½å€¼éœ€ä¸º1æ‰èƒ½ä¿è¯è¾“å‡ºå…¨ä½ç”µå¹³ã€‚ä»¥ä¸‹å®å¯¹HW_PWM_MINNUMè¿›è¡Œå¤„
             -ç†ã€‚
 518   1      #if (LOLI3_RECV_PWM_MINNUM/4 >= 1)
 519   1        #define HW_PWM_MINNUM   (LOLI3_RECV_PWM_MINNUM/4)
 520   1      #else
                #define HW_PWM_MINNUM   1
              #endif
 523   1      
 524   1        if(ch==1)
 525   1        {
 526   2          if( pwm>=HW_PWM_MINNUM )  PCA_PWM2=0x00;  // CCAPxH&CCAPnLç¬¬9ä½æ•°ä¸º0
 527   2          else                      PCA_PWM2=0x03;  // CCAPxH&CCAPnLç¬¬9ä½æ•°ä¸º1
 528   2          CCAP2H = 255-pwm;         // CLæº¢å‡ºæ—¶EPCnH&CCAPnHæ•°æ®æ‰è½½å…¥EPCnL&CCAPnL
 529   2        }
 530   1        else if(ch==2)
 531   1        {
 532   2          if( pwm>=HW_PWM_MINNUM )  PCA_PWM1=0x00;
 533   2          else                      PCA_PWM1=0x03;
 534   2          CCAP1H = 255-pwm;
 535   2        }
 536   1      #elif STC_8H
C51 COMPILER V9.59.0.0   LOLI3_RECV_SYS_STC                                                12/13/2023 00:12:42 PAGE 10  

              /*-----------------------------------------------------------------------------/
              
              ç¡¬ä»¶CH1/CH2/CH6/CH7å¯¹åº”PWM6_2/PWM5_2/PWM8_2/PWM7_2
                
              /----------------------------------------------------------------------------*/
              #if (LOLI3_RECV_PWM_MINNUM/4 >= 1)
                #define HW_PWM_MINNUM   (LOLI3_RECV_PWM_MINNUM/4)
              #else
                #define HW_PWM_MINNUM   1
              #endif
                
                if(ch==1)
                {
                  if( pwm>=HW_PWM_MINNUM )  PWMB_CCR6 = pwm;
                  else                      PWMB_CCR6 = 0;
                }
                else if(ch==2)
                {
                  if( pwm>=HW_PWM_MINNUM )  PWMB_CCR5 = pwm;
                  else                      PWMB_CCR5 = 0;
                }
                else if(ch==6)
                {
                  if( pwm>=HW_PWM_MINNUM )  PWMB_CCR8 = pwm;
                  else                      PWMB_CCR8 = 0;
                }
                else if(ch==7)
                {
                  if( pwm>=HW_PWM_MINNUM )  PWMB_CCR7 = pwm;
                  else                      PWMB_CCR7 = 0;
                }
                
              /*-----------------------------------------------------------------------------/
              /----------------------------------------------------------------------------*/
              #endif
 572   1      }
 573          #pragma AREGS
 574          
 575          /*////////////////////////////////////////////////////////////////////////////*/
 576          
 577          void LED_on(void)
 578          {
 579   1        LED_ON();
 580   1      }
 581          
 582          void LED_off(void)
 583          {
 584   1        LED_OFF();
 585   1      }
 586          
 587          /*////////////////////////////////////////////////////////////////////////////*/
 588          // NRF24L01 SPIç«¯å£IOæ¨¡å¼åˆå§‹åŒ–
 589          void SPI_init_0()
 590          {
 591   1        // set SCK/MOSI/NSS output mode, MISO input mode
 592   1        //é»˜è®¤å‡†åŒå‘IOï¼Œæ— éœ€é…ç½®ä»£ç 
 593   1      }
 594          
 595          void SPI_init_1(void)
 596          {
 597   1        // then set SCK/MOSI 0, set NNS 1.
 598   1        SPI_SLAVE_DIS();
C51 COMPILER V9.59.0.0   LOLI3_RECV_SYS_STC                                                12/13/2023 00:12:42 PAGE 11  

 599   1        SPI_SCK_CLR();
 600   1        SPI_MOSI_CLR();
 601   1      }
 602          
 603          /*////////////////////////////////////////////////////////////////////////////*/
 604          //ROMå­˜å‚¨
 605          u8 EEPROM_read(u16 addr)  //è¯»æ•°æ®
 606          {
 607   1        IAP_CMD=0x01;
 608   1      
 609   1        IAP_ADDRH=addr>>8;
 610   1        IAP_ADDRL=addr;
 611   1      
 612   1        IAP_TRIG=0x5a;
 613   1        IAP_TRIG=0xa5;
 614   1        _nop_();
 615   1      
 616   1        return IAP_DATA;
 617   1      }
 618          
 619          void EEPROM_write(u16 addr,u8 byte) //å†™å…¥æ•°æ®
 620          {
 621   1        IAP_CMD=0x02;
 622   1        IAP_DATA=byte;
 623   1      
 624   1        IAP_ADDRH=addr>>8;
 625   1        IAP_ADDRL=addr;
 626   1      
 627   1        IAP_TRIG=0x5a;
 628   1        IAP_TRIG=0xa5;
 629   1        _nop_();
 630   1      }
 631          
 632          void EEPROM_cleanPage(u8 addrPage)  //æ“¦é™¤æ‰‡åŒºæ•°æ®
 633          {
 634   1        IAP_CMD=0x03;
 635   1      
 636   1        IAP_ADDRH=(SIZE_EEPROM_PAGE*addrPage)>>8;
 637   1        IAP_ADDRL=0;
 638   1      
 639   1        IAP_TRIG=0x5a;
 640   1        IAP_TRIG=0xa5;
 641   1        _nop_();
 642   1      }
 643          
 644          /*////////////////////////////////////////////////////////////////////////////*/
 645          
 646          void hw_sys_init()
 647          {
 648   1        //ç¦æ­¢æ‰€æœ‰ä¸­æ–­
 649   1        IE = 0;
 650   1        IE2= 0;
 651   1      
 652   1        //ç«¯å£åŠŸèƒ½åˆå§‹åŒ–
 653   1        hw_io_chs_init();
 654   1        //å¼€æœºå»¶æ—¶ä»¥é¿è¿‡ç”µæºæ³¢åŠ¨
 655   1        hw_delay_ms(200); // å‚æ•°ç±»å‹u8ï¼Œä¸å¤§äº255ã€‚
 656   1        hw_delay_ms(200);
 657   1        //SBUSåŠŸèƒ½åˆå§‹åŒ–-------------------ï¼ˆä½¿ç”¨å®šæ—¶å™¨2ï¼‰
 658   1        hw_uart_init(UART_BPS); //init for debug and SBUS output
 659   1        //ç”µå‹æµ‹é‡åŠŸèƒ½åˆå§‹åŒ–
 660   1        hw_adc_init();
C51 COMPILER V9.59.0.0   LOLI3_RECV_SYS_STC                                                12/13/2023 00:12:42 PAGE 12  

 661   1        //ç³»ç»Ÿå¿ƒè·³åŠŸèƒ½åˆå§‹åŒ–---------------ï¼ˆSTC15Wä½¿ç”¨PCAå®šæ—¶å™¨æ¨¡å—0ä¸­æ–­ / STC8Hä½¿ç”¨å®šæ—¶å
             -™¨1ï¼‰
 662   1        hw_tick_init();
 663   1        //é€šé“è¾“å‡ºåŠŸèƒ½åˆå§‹åŒ–---------------ï¼ˆä½¿ç”¨å®šæ—¶å™¨0ï¼‰
 664   1        hw_output_init();
 665   1        
 666   1        INTERRUPT_en(); // addin(20230925): delayçš„å®ç°å¯èƒ½ä¾èµ–ä¸­æ–­ï¼›æˆ–è€…æŠŠdelayæ›¿æ¢æˆhw_delay_ms
             -?
 667   1      }
 668          
 669          /******************************************************************************/
 670          /*-DO NOT ADD YOUR CODE AFTER HERE!-*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\-WIDTH: 80-*/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    572    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       3
   IDATA SIZE       =      6    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
